---
layout: post
title: iOS 개발자로 취업하기 > Interview 준비
category: etc
tags: [etc]
comments: true
---

> iOS 개발자로서 취업준비를 하면서 정리해본 면접 질문지 입니다.     
잘못된 내용이 있거나 추가하면 좋을 내용이 있다면 언제든지 댓글 남겨주세요 :)

<hr>

아오스 개발자가 되기 위해서는 코딩실력도 있어야하지만, 우선 취업을 하기 위해 면접을 거치겠쥬..?<br>
면접에 대비하기 위해 면접 질문을 긁어 보았습니다.

[이전에 작성했던 질문지](https://github.com/zehye/ios_Interview)는 요기에! <br>
실제 면접에서 받은 질문도 정리해보았고, 면접을 준비하면서 실제 면접 본 사람들에게 받은 질문지를 싹싹 긁어 놓은것이라 위 깃헙에 정리해 놓은 글은 아오스 개발자만이 아닌 웹 백엔드 개발자의 질문도 간간히 들어가있다는것을 참고해주세요.

> 아래부터는 질문 뿐만이 아니라, 공부하고 느낀것을 토대로 간단히 작성해보았습니다.


### 공통적으로 생각해보면 좋은 질문


- 코딩 왜 시작했냐
 - 처음 개발자를 만난 계기, 협업을 하면서 소통의 필요성, 실제 배워보면서 원래 일했던 업계와의 차이점, 나라는 사람과의 적합성

- 나의 장 단점
  - 장점: 꼼꼼하고 끈기가 있음. 한번 시작한건 쉽게 놓지 않음
  - 단점: 체력 > 운동 다시 시작함
  - 늦게 시작한만큼 뒤쳐지지 않겠나? > 장점으로 다시 어필

- 서버에서 클라이언트 변화이유
  - 서버에서 느낀점과 클라이언트에서의 차이점
  - 눈에 한번에 보여지고 내가 적용해놓은 기능을 유저가 직접적으로 사용한다는 점이 매력적

- 지원동기
  - 당사 서비스에 대한 관심

- 흥미롭게 본 오픈소스 라이브러리가 무엇

- 최근 겪은 기술적 어려움은 무엇이고 어떻게 해결했느냐
  - 라이브러리와 연결지어서 생각했음
  - 최근 alamofire를 사용하면서 애먹은 기억이 있어서 그걸 살림

- 문제 해결에 오랜시간이 걸릴경우 이를 어떻게 해결할 것인가
  - 듀를 조금더 세부적으로 끊어서 사고하려하기
  - 작은 성취들을 만들어 멘탈관리를 하고 그럼에도 해결되지 않을때는 도움요청

- 커리어 골 / 10년 뒤 달성하고자 하는 목표
- 이회사는 당신의 목표에 얼마나 도움이 될것인가
- 회사에 원하는 것
- 하고싶은 질문
  - 개발자가 몇명인지? = 사수의 유무
  - 앞으로 기술 스택의 변화는 어찌될지?


### swift / iOS

- **Swift 특징**
    - 옵젝씨와 스위프트 차이 : 포인터 유무, 옵셔널 유무, 브릿지 파일의 유무

- **Closure**: 이름없는 함수, 파라미터와 반환타입을 생략해 코드를 축약할 수 있음

- **let과 var의 차이**
  - let: 상수, 상수 선언시 값 변경 불가능
  - var: 변수, 변수 선언시 값 변경 가능

- **AutoLayout의 장단점**
  - 장점: 인터페이스의 절대적인 좌표가 아닌 동적인 상대적인 좌표가 필요할때 유용
  - 단점:

- **MVC 패턴**(각 역할과 흐름)
  - model: 로직을 구현하는 부분
  - view: 화면에 보여질 부분(ui관련된 것들만 담는다)
  - controller: 모델을 해석해 뷰에게 보내줌

- model > view: 소통못함
  - model은 ui와 독립적이지만 view는 ui에 의존 & view는 일반객체로 버튼 자체가 무엇을하는 지는 모름
- model > controller: 소통은 가능함
  - model의 데이터가 변경되는 경우 KVO, Notification을 통해 소통이 가능하긴 함
- controller > model: 소통 가능
  - controller는 model의 모든 기능과 소통이 가능 > 무엇을 어떻게 보여질지에 대한 부분이기에
- controller > view: 소통 가능
  - outlet을 통해 무한한 대화가 가능
- view > controller: 소통은 가능함
  - delegate, dataSource를 통해 가능 & target-action

- MVVM
  - model: 로직을 구현하는 부분
  - view: 화면에 데이터가 뿌려지는 부분
  - viewmodel: model로부터 데이터를 가져오는 부분  

- **Delegate와 Notification의 차이**
    - **Delegate**
      - 프로토콜을 통해 정의
      - 로직의 흐름을 따라가기 쉬움
      - delegate안에 nil이 할당되지 않게 주의
      - 많은 객체들에게 이벤트를 알려주기 어려움
    - **Notification**
      - Notification center 라는 싱글턴 객체를 통해 옵저버를 등록한 객체게에 Notification post를 하는 방식
      - 다수의 객체들에게 동시에 이벤트 발생을 알려줄 수 있음
      - 추적이 쉽지 않음
    - Delegate retain되는지 안되는지?
        - retain cycle :

- Singleton패턴: 특정 클래스의 인스턴스가 오직 하나임을 보장하는 객체
  - UserDefaults, NotificationCenter, UIApplication, FileManager, UILSession

- KVC와 KVO란(동작방식)
  - KVO: 특정 키의 값 변화를 감지하기 위한 기능 > `@objc dynamic`

- willset, didset: 프로퍼티의 값이 변경되기 전, 후를 감지하여 그때 원하는 작업을 수행할 수 있다.
  - willset: 프로퍼티의 값이 변경된 직후를 감지
  - didset: 프로퍼티의 값이 변경되지 직전을 감지

- wilset, didset과 KVO의 차이
  - 우리가 타입을 만드는 경우에는 willset, didset을 자유롭게 구현이 가능하겠지만, 외부 라이브러리 혹은 다른 사람이 구현한 타입이라면 이를 내부에서 마음대로 작업할수는 없을것. 따라서 이런때 타입의 프로퍼티들이 변경되는지에 대한 확인은 KVO로 관찰할 수 있다. 따라서 KVO는 상속이나 코드의 변경없이 옵저빙할수 있다.

- ios에서 https를 더 지향하는 이유: 사용자 정보보호에 대한 중요성 대두

- http도 허용되는 예외상황
  - 로컬 네트워크에 연결할때
  - webkit을 통한 콘텐츠 요청할때
  - AVFoundation 프레임워크를 통한 스트리밍 서비스를 할때

- Optional
    - 왜 필요한가: 변수안에 값이 있을지 없을지 확실하지 않을때 사용
      - 기본적으로 변수에 값을 할당할때 반드시 non-Optional한 값을 넣어줘야한다.
      - nil은 어떠한 값도 아니다.
      - safe, fast, expressive
    - ?와 !
      - ?: 값을 가지고 있다면 값을 반환해주고 없다면 nil을 반환(nil도 메모리는 차지하고 있음)
      - !: 강제 언래핑, 상자 안에 값이 있든 없든 가지고 옴 > nil이 아닐거라고 확신할때 사용해야함
    - 옵셔널 타입의 변수를 가져오는 방법
      - 옵셔널 바이닝: if let > 값이 nil인지 아닌지에 따라 결과를 달리하고 싶을 때 사용
      - 옵셔널 체이닝: ?.?. > 하위 프로퍼티 값으로 옵셔널 값이 있는지 없는지 계속 확인하면서 파고 들어가는 방법
        - 중간에 하나라도 nil이 있다면 nil을 반환해준다
    - 안전한 ? 아닌 !을 사용하는 이유: 값이 있다는것을 확신할때 사용

- Class/Struct/Enum
    - 값타입과 참조타입
      - 값타입: 데이터 전달 시 값을 복사해서 전달
      - 참조타입: 값의 메모리 위치를 전달
    - class: 참조타입, 상속 가능
    - struct : 값 타입, 상속 불가능
        - class와 struct 사용 기준 : 참조가 아닌 복사를 원할때, 상속이 불필요할때
    - enum: 값 타입, 상속 불가능


- instance method와 type method의 차이 : 인스턴스 메소드는 특정 타입의 인스턴스화를 통해 호출할 수 있으나,

- 프로토콜: 특정 작업이나 기능에 맞게 메소드, 프로퍼티 등을 정의한 약속/규약, 프로토콜 내에선 정의만 하고 구현은 해당 프로토콜을 채택하는 곳에서 함

- Extension: 기존의 클래스/구조체/열거형에 기능을 추가 확장시키는 것, 기존 기능 재정의는 불가능, convenience init 추가 가능

- Hashable은 무엇이고, 왜 Equatable을 상속하는가?
- mutataing :

- **접근 제어자 종류** : 데이터 은닉화. 코드의 세부 구현사항을 숨기고 접근 하는 것에 있어 제한을 둘수있음
  - open: 외부의 다른 모듈에서 import 가능, import한 모듈에서 subclass, override 가능
  - public: 외부의 다른 모듈에서 import 가능, import한 모듈에서 subclass, override 불가능
  - internal: 자신의 모듈 내에서만 접근 가능 > 프로젝트 내부용
  - fileprivate: .swift 파일 안에서만 접근 가능 > 같은 소스 파일 안에서만 접근 가능
  - private: 함수안에서 선언하면 그 함수 안에서만 접근 가능

- defer: 현재의 코드 블럭을 나가기 전에 꼭 실행해야하는 코드를 작성하여 반드시 작업하도록 도와주는 함수
    - defer 호출 순서: 선언된 역순으로 진행
    - defer 호출되지 않는 경우 :

- 생성자(designated/convenience/required) 차이
  - designated: 초기화 이니셜 라이저. 모든 프로퍼티들이 초기화될 수 있도록 해준다. 따라서 모든 클래스는 하나 이상의 designated init을 가진다.
  - convenience: 보조 이니셜 라이저. 기본적으로 designated init이 선언되어야 사용할 수 있다.
  - required:

- OOP와 POP
    - OOP:
    - POP: 클래스를 통해 기능적으로 하나의 원본을 여러군데에서 사용해야하는 경우도 있지만, 멀티쓰레드 환경에서는 한 원본을 두고 여러작업이 동시에 진행되게 되면 원본 데이터가 꼬일 가능성이 크기때문에 하나의 원본으로 작업해야할 필요가 없다면 가급적으로 값 타입인 구조체나 열거형을 사용하는 것을 권장한다.

- 고차함수
    - sort/sorted: 값을 정렬 > sort: 원본에 영향줌, sorted: 원본에 영향 안줌
    - filter: 필터된 값을 반환
    - reduce: 최종 결과값만 반환
    - map: 값을 변경하되 이를 반환받을때 배열로 받음
    - compactMap: 옵셔널이 포함된 배열안에 nil을 제거하고 옵셔널 바인딩을 하고싶을 때 사용

- ARC
    - 메모리 사용을 관리하고 추적하기 위해 사용
    - GC와의 차이점: ARC는 컴파일시 실행, GC는 프로그램 동작 중 실행
    - Retain Count(=reference count)
      - 할당: 값을 변수에 할당할때 증가
      - 해제: 변수 생명주기가 끝나거나 nil이 할당되거나 인스턴스가 메모리에서 해체될때
    - strong: 변수가 할당되면 rc+1 > 인스턴스가 계속해서 메모리에 남아있어야하는 경우 사용
    - weak: 변수가 할당되어도 rc 오르지 않으면서 참조함
      - 자신이 참조하던 인스턴스에 nil을 할당할 수 있어야하기 때문에 항상 옵셔널 변수로만 선언이 가능하다
    - unowned: rc 증가하지않으면서 참조
      - 그러나 자신이 참조하는 인스턴스가 항상 메모리에 남아있을 것이라는 전제를 기반으로 동작
      - 자신이 참조하는 인스턴스가 메모리에서 해제되더라도 스스로 nil을 할당하지 않음 > 옵셔널 변수가 아니어도 됨
      - 그러나 미소유 참조를 하면서 메모리에서 해제된 인스턴스에 접근하려한다면 런타임에러를 발생시킴
      - 미소유 참조는 참조를 하는 동안 메모리에서 해제되지 않을 것이라는 확신이 있을 때 사용
    - unowned와 weak의 차이
      - 둘다 참조를 할때 rc가 증가되지 않는다는 공통점이 있음
      - 그러나 weak는 자신이 참조하던 인스턴스에 nil을 할당할 수 있어야 하기 때문에 항상 옵셔널 변수여야 하지만
      - unowned는 자신이 참조하는 인스턴스가 메모리에 해제되더라도 nil을 할당하지 않음
    - 강한 순환 참조는 어떨때에 발생하는가: 각각의 인스턴스가 서로를 꽉 잡고 있어서 rc가 계속 남아있는 경우
      - person과 room class 예시를 생각하자

- 스토리보드를 이용했을 때의 장단점 :

- safeArea: 콘텐츠가 상태바, 네이게이션 영역, 탭바, 툴바 영역을 가리는 것을 방지하는 영역

- bounds와 frame의 차이
  - bounds: 자신(해당뷰)의 좌표계 기준
  - frame: 슈퍼뷰 기준의 좌표

- 실제 디바이스의 유무에 따라 개발환경에서 할 수 있는 것과 없는 것: 카메라

- scene delegate :
- app delegate :
    - UIWindow 역할 :

- 앱이 in active 되는 시나리오  
  - 네이버에서 기사를 읽고 이를 카카오톡으로 공유한다고 할때, 공유하기 버튼을 누르면 카카오톡 앱이 active상태가 되고 네이버 앱은 in-active 상태가 된다.

- App LifeCycle
  - not running: 앱이 실행되지 않았거나 종료됨
  - in-active: 앱이 foreground에서 머물지만 아직 실행되지는 않음(이벤트를 받지못함) 이 상태에서 바로 다른 상태로 전이됨
  - active: 앱이 실행된 상태이며 이벤트를 받을 수 있음
  - background: 앱이 background에서 코드를 실행중. (은행앱처럼 추가시간을 요청하는 앱은 이 상태에 머물수 있다) > background에서도 실행되는앱(음악앱)
  - suspended: 앱이 background에 있지만 코드를 실행하지 않음. 일시중지 된 앱은 아직 메모리에 남아있으며, 메모리가 부족해지면 예고없이 해당 앱을 중단시킨다.

- VC LifeCycle
  - viewDidLoad: 뷰가 메모리에 로드된 직후 호출 > 초기화 할 코드를 작성해줌. 초기 한번만 로드 됨
  - viewWillAppear: 뷰가 보여지기 직전에 호출 > 다른뷰로 갔다 돌아올때마다 호출되기에 화면 나타날때마다 수행할 작업 작성
  - viewDidAppear: 뷰가 보여진 다음에 호출 > 뷰가 나타났다는것을 컨트롤러에게 알리는 역할
  - viewWillDisAppear: 뷰가 사라지기 직전에 호출 혹은 다른 뷰로 넘어가지 직전에 호출됨
  - viewDidDisAppear: 뷰가 사라지고 호출 > 화면에 사라지면 필요없어지는 작업들을 진행

- 비동기 프로그래밍: 프로그램의 주 실행흐름을 멈춰서 기다리지 않고 다음 작업을 실행할수 있게 하는 방식
  - 동시성 프로그래밍: 동시에 실행되는 것처럼 보이게 하는 방식
  - 병렬성 프로그래밍: 물리적으로 정확히 동시에 실행시키는 방식

- 동시성 vs 병렬성
  - 동시성: 한명이 번갈아가며 처리
  - 병렬성: N:N

- NSOperationQueue와 GCD Queue의 차이 :

- GCD API 동작방식과 필요성 :

- Custom View를 만드는 방법 → 프로젝트 예시 들면서 :
- App Bundle 구조와 역할 :
- UIView에서 Layer는 무엇이고, 어떤 역할 :
- 앱 화면 콘텐츠를 표시하는 로직과 관리를 담당하는 객체 :
- 앱 콘텐츠나 데이터 자체를 저장/보관하는 특별한 객체 : 아카이빙(NSCoding), UserDefaults
- Global DispatchQueue의 Qos 종류와 각각 어떤 의미 :

---

- Git의 장점: 파일의 변화를 시간에 따라 기록이 가능해 관리가 가능하다. & 브랜치

- Rest API: 서버와 클라이언트가 데이터를 주고받는 방식
  - post: 리소스 생성
  - get: 리소스 읽어오기
  - put: 리소스 수정
    - patch: put은 리소스 전체를 수정, patch는 일부를 변경 따라서 update의 의미에서는 patch가 더 적절
  - delete: 리소스 삭제

- 상태코드
  - 200: 성공
  - 300: 리다이렉션
  - 400: 클라이언트 에러
  - 500: 서버에러

- Garbage Collection: 클래스로부터 필요에 따라 만든 객체가 더이상 필요 없어졌을 때(사용되지 않을 때), 회수하는 역할. 즉 메모리에서 날려버림으로써 메모리를 여유롭게 만들어준다. (임자없는 객체를 회수하는 역할)
- Cache :

- PNG와 JPG의 차이 :
- Dynamic Programming :
- Virtual Memory :
- Database Index 추가의 장단점 :
- HDD, SSD, DRAM 각각의 성능 :

---
- process와 thread 비교 설명
  - 프로그램: 보조기억장치에 저장되어있는 실행코드
  - 프로세스: 프로그램을 실행시켜 메모리 상에서 실행되는 작업상태
  - 스레드: 프로세스 내에서 실행되는 작업흐름의 단위
  - 멀티프로세스: 보통 하나의 프로세스안에 하나의 스레드가 가지고 있지만, 환경에 따라 둘 이상의 스레드를 동시에 실행하는 것

- multi thread 환경 장단점
  - 장점: 여러개의 실행흐름을 가져갈 수 있음
  - 단점: 쓰레드는 프로세스처럼 완전히 독립적인 구조가 아니기에 환경적으로 쓰레드 사이에 공유하는 구간이 있다.


- DFS와 BFS란?
    - 그 외의 그래프 탐색 방법?
- Array와 Linked List란?
- Hash란?
- quick sort :


### 프로젝트 관련

- 비캠퍼스
- 모플
- 술술
    - SDWebImage와 Kingfisher의 차이 :
    - MVVM과 MVC :

### 창의수학

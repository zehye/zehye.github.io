---
layout: post
title: iOS 개발자로 취업하기 > Interview 준비
category: etc
tags: [etc]
comments: true
---

> iOS 개발자로서 취업준비를 하면서 정리해본 면접 질문지 입니다.     
잘못된 내용이 있거나 추가하면 좋을 내용이 있다면 언제든지 댓글 남겨주세요 :)

<hr>

아오스 개발자가 되기 위해서는 코딩실력도 있어야하지만, 우선 취업을 하기 위해 면접을 거치겠쥬..?<br>
면접에 대비하기 위해 면접 질문을 긁어 보았습니다.

[이전에 작성했던 질문지](https://github.com/zehye/ios_Interview)는 요기에! <br>
실제 면접에서 받은 질문도 정리해보았고, 면접을 준비하면서 실제 면접 본 사람들에게 받은 질문지를 싹싹 긁어 놓은것이라 위 깃헙에 정리해 놓은 글은 아오스 개발자만이 아닌 웹 백엔드 개발자의 질문도 간간히 들어가있다는것을 참고해주세요.

> 아래부터는 질문 뿐만이 아니라, 공부하고 느낀것을 토대로 간단히 작성해보았습니다.


### 공통적으로 생각해보면 좋은 질문

- 1분 자기소개

- 코딩 왜 시작했냐
  - 처음 개발자를 만난 계기, 협업을 하면서 소통의 필요성, 실제 배워보면서 원래 일했던 업계와의 차이점, 나라는 사람과의 적합성

- 나의 장 단점
  - 장점: 꼼꼼하고 끈기가 있음. 한번 시작한건 쉽게 놓지 않음
  - 단점: 체력 > 운동 다시 시작함
  - 늦게 시작한만큼 뒤쳐지지 않겠나? > 장점으로 다시 어필

- 서버에서 클라이언트 변화이유
  - 서버에서 느낀점과 클라이언트에서의 차이점
  - 눈에 한번에 보여지고 내가 적용해놓은 기능을 유저가 직접적으로 사용한다는 점이 매력적

- 지원동기
  - 당사 서비스에 대한 관심

- 흥미롭게 본 오픈소스 라이브러리가 무엇

- 최근 겪은 기술적 어려움은 무엇이고 어떻게 해결했느냐
  - 라이브러리와 연결지어서 생각했음
  - 최근 alamofire를 사용하면서 애먹은 기억이 있어서 그걸 살림

- 문제 해결에 오랜시간이 걸릴경우 이를 어떻게 해결할 것인가
  - 듀를 조금더 세부적으로 끊어서 사고하려하기
  - 작은 성취들을 만들어 멘탈관리를 하고 그럼에도 해결되지 않을때는 도움요청

- 커리어 골 / 10년 뒤 달성하고자 하는 목표
- 이회사는 당신의 목표에 얼마나 도움이 될것인가
- 회사에 원하는 것
- 하고싶은 질문
  - 개발자가 몇명인지? = 사수의 유무
  - 앞으로 기술 스택의 변화는 어찌될지?


### swift / iOS

- **Swift 특징**
  - 안전성(guard구문, 오류처리, 강력한 타입통제)
  - 신속성(설계를 성능을 최대한 C언어에 가깝게 맞춤)
  - 더 나은 표현성(그간 발전된 프로그래밍 언어를 모두 참고하여 사용하기 편하고 보기좋은 문법을 구사하려 노력)

- 옵젝씨와 스위프트 차이 : 포인터 유무, 옵셔널 유무, 브릿지 파일의 유무(헤더파일, 스크립트 파일로 나뉘어 사용하다가 이제는 swift 파일 하나로)

- **Closure**: 이름없는 함수, 파라미터와 반환타입을 생략해 코드를 축약할 수 있음, 클래스처럼 참조타입이다(상수에 클로저를 할당을 해도 값이 변할수있다)
  - okhandler> 상수를 선언했어도 okhandler를 사용하게되면 그 값이 변함

- **let과 var의 차이**
  - let: 상수, 상수 선언시 값 변경 불가능
  - var: 변수, 변수 선언시 값 변경 가능

- **AutoLayout의 장단점**
  - 장점: 인터페이스의 절대적인 좌표가 아닌 동적인 상대적인 좌표가 필요할때 유용
  - 단점:

- 스토리 보드의 장단점
  - 장점: 시각화, 시간절약, 낮은 진입장벽
  - 단점: 로딩시간 오래걸림(앱이 무거워짐), 협업할때 변화에 대한 추적이 어렵다, merge의 어려움

- **MVC 패턴**(각 역할과 흐름)
  - model: 로직을 구현하는 부분
  - view: 화면에 보여질 부분(ui관련된 것들만 담는다)
  - controller: 모델을 해석해 뷰에게 보내줌

- model > view: 소통못함
  - model은 ui와 독립적이지만 view는 ui에 의존 & view는 일반객체로 버튼 자체가 무엇을하는 지는 모름
- model > controller: 소통은 가능함
  - model의 데이터가 변경되는 경우 KVO, Notification을 통해 소통이 가능하긴 함
- controller > model: 소통 가능
  - controller는 model의 모든 기능과 소통이 가능 > 무엇을 어떻게 보여질지에 대한 부분이기에
- controller > view: 소통 가능
  - outlet을 통해 무한한 대화가 가능
- view > controller: 소통은 가능함
  - delegate, dataSource를 통해 가능 & target-action

- MVVM: 객체가 독립적이라 자동화테스트에 용이, 유지보수가 좋음
  - model: 로직을 구현하는 부분
  - view: 화면에 데이터가 뿌려지는 부분
  - viewmodel: model로부터 데이터를 가져오는 부분  

- **Delegate와 Notification의 차이**
    - **Delegate**
      - 프로토콜을 통해 정의
      - 로직의 흐름을 따라가기 쉬움
      - delegate안에 nil이 할당되지 않게 주의
      - 많은 객체들에게 이벤트를 알려주기 어려움
    - **Notification**
      - Notification center 라는 싱글턴 객체를 통해 옵저버를 등록한 객체게에 Notification post를 하는 방식
      - 다수의 객체들에게 동시에 이벤트 발생을 알려줄 수 있음
      - 추적이 쉽지 않음

- Singleton패턴: 특정 클래스의 인스턴스가 오직 하나임을 보장하는 객체
  - UserDefaults, NotificationCenter, UIApplication, FileManager, URLSession

- KVC와 KVO란(동작방식)
  - KVO: 특정 키의 값 변화를 감지하기 위한 기능 > `@objc dynamic`

- willset, didset: 프로퍼티의 값이 변경되기 전, 후를 감지하여 그때 원하는 작업을 수행할 수 있다.
  - willset: 프로퍼티의 값이 변경된 직후를 감지
  - didset: 프로퍼티의 값이 변경되지 직전을 감지

- willset, didset과 KVO의 차이
  - 우리가 타입을 만드는 경우에는 willset, didset을 자유롭게 구현이 가능하겠지만, 외부 라이브러리 혹은 다른 사람이 구현한 타입이라면 이를 내부에서 마음대로 작업할수는 없을것. 따라서 이런때 타입의 프로퍼티들이 변경되는지에 대한 확인은 KVO로 관찰할 수 있다. 따라서 KVO는 상속이나 코드의 변경없이 옵저빙할수 있다.

- ios에서 https를 더 지향하는 이유: 사용자 정보보호에 대한 중요성 대두

- http도 허용되는 예외상황
  - 로컬 네트워크에 연결할때
  - webkit을 통한 콘텐츠 요청할때
  - AVFoundation 프레임워크를 통한 스트리밍 서비스를 할때

- Optional
    - 왜 필요한가: 변수안에 값이 있을지 없을지 확실하지 않을때 사용
      - 기본적으로 변수에 값을 할당할때 반드시 non-Optional한 값을 넣어줘야한다.
      - nil은 어떠한 값도 아니다.
      - safe, fast, expressive
    - ?와 !
      - ?: 값을 가지고 있다면 값을 반환해주고 없다면 nil을 반환(nil도 메모리는 차지하고 있음)
      - !: 강제 언래핑, 상자 안에 값이 있든 없든 가지고 옴 > nil이 아닐거라고 확신할때 사용해야함
    - 옵셔널 타입의 변수를 가져오는 방법
      - 옵셔널 바이닝: if let > 값이 nil인지 아닌지에 따라 결과를 달리하고 싶을 때 사용
      - 옵셔널 체이닝: ?.?. > 하위 프로퍼티 값으로 옵셔널 값이 있는지 없는지 계속 확인하면서 파고 들어가는 방법
        - 중간에 하나라도 nil이 있다면 nil을 반환해준다
    - 안전한 ? 아닌 !을 사용하는 이유: 값이 있다는것을 확신할때 사용

- Class/Struct/Enum
    - 값타입과 참조타입
      - 값타입: 데이터 전달 시 값을 복사해서 전달
      - 참조타입: 값의 메모리 위치를 전달
    - class: 참조타입, 상속 가능, deinit을 통해 메모리 해제가 가능하다.
    - struct : 값 타입, 상속 불가능
        - **class와 struct 사용 기준 : 참조가 아닌 복사를 원할때, 상속이 불필요할때**
    - enum: 값 타입, 상속 불가능


- instance method와 type method의 차이: 인스턴스 메소드는 특정 타입의 인스턴스화를 통해 호출할 수 있으나, 타입 메소드는 인스턴스화없이 타입 객체 자체를 통해 호출 가능
  - class type method : 클래스에서만 구현 가능, 재정의 가능
  - static type method : 기본

- 프로토콜: 특정 작업이나 기능에 맞게 메소드, 프로퍼티 등을 정의한 약속/규약, 프로토콜 내에선 정의만 하고 구현은 해당 프로토콜을 채택하는 곳에서 함
- Extension: 기존의 클래스/구조체/열거형에 기능을 추가 확장시키는 것, 기존 기능 재정의는 불가능, convenience init 추가 가능

- Hashable은 무엇이고, 왜 Equatable을 상속하는가?
- mutataing :

- **접근 제어자 종류** : 데이터 은닉화. 코드의 세부 구현사항을 숨기고 접근 하는 것에 있어 제한을 둘수있음
  - open: 외부의 다른 모듈에서 import 가능, import한 모듈에서 subclass, override 가능
  - public: 외부의 다른 모듈에서 import 가능, import한 모듈에서 subclass, override 불가능
  - internal: 자신의 모듈 내에서만 접근 가능 > 프로젝트 내부용
  - fileprivate: .swift 파일 안에서만 접근 가능 > 같은 소스 파일 안에서만 접근 가능
  - private: 함수안에서 선언하면 그 함수 안에서만 접근 가능

- defer: 현재의 코드 블럭을 나가기 전에 꼭 실행해야하는 코드를 작성하여 반드시 작업하도록 도와주는 함수
    - defer 호출 순서: 선언된 역순으로 진행
    - defer 호출되지 않는 경우 :

- 생성자(designated/convenience/required) 차이
  - designated: 초기화 이니셜 라이저. 모든 프로퍼티들이 초기화될 수 있도록 해준다. 따라서 모든 클래스는 하나 이상의 designated init을 가진다.
  - convenience: 보조 이니셜 라이저. 기본적으로 designated init이 선언되어야 사용할 수 있다.
  - 둘 사용의 기준점: convenience init는 init에서 지정한 파라미터 외의 값을 받고자 할 때 사용 + 사용자 정의로 값을 변형해서 저장하고자 할 때 사용, init을 먼저 구현해줘야 구현할 수 있고 `self.init`을 호출해줘야 함
  - required:

- **OOP와 POP**
    - OOP: 캡슐화(정보은닉), 상속가능, 추상화(필요한 정보만을 중심으로 간소화하는 것 - 객체간의 공통적인 속성과 기능으로 추상화), 다형성(재정의를 통해 다른 방식의 코드를 실행할 수 있도록 하는 것>override, overloading - 형태가 같은데 다른 기능을 하는 것을 의미한다 (같은 동작이지만 다른 결과물이 나올때 다형이라고 생각하면 된다))
    - POP: 확장성(수평적인 기능확장), 상속가능, 안정성:클래스를 통해 기능적으로 하나의 원본을 여러군데에서 사용해야하는 경우도 있지만, 멀티쓰레드 환경에서는 한 원본을 두고 여러작업이 동시에 진행되게 되면 원본 데이터가 꼬일 가능성이 크기때문에 하나의 원본으로 작업해야할 필요가 없다면 가급적으로 값 타입인 구조체나 열거형을 사용하는 것을 권장한다. + 값: 메모리 추적이 간편

- 고차함수
    - sort/sorted: 값을 정렬 > sort: 원본에 영향줌, sorted: 원본에 영향 안줌
    - filter: 필터된 값을 반환
    - reduce: 초기값이 있고 초기값과 첫번째 요소 ~ 끝번째 요소까지의 실행된 최종 결과값만을 반환
    - map: 값을 변경하되 이를 반환받을때 배열로 받음
    - compactMap: 옵셔널이 포함된 배열안에 nil을 제거하고 옵셔널 바인딩을 하고싶을 때 사용(+ 값의 변형도 가능) → 새로운 배열 반환

- ARC
    - 메모리 사용을 관리하고 추적하기 위해 사용
    - GC와의 차이점: ARC는 컴파일시 실행, GC는 프로그램 동작 중 실행
    - Retain Count(=reference count)
      - 할당: 값을 변수에 할당할때 증가
      - 해제: 변수 생명주기가 끝나거나 nil이 할당되거나 인스턴스가 메모리에서 해체될때
    - strong: 변수가 할당되면 rc+1 > 인스턴스가 계속해서 메모리에 남아있어야하는 경우 사용
    - weak: 변수가 할당되어도 rc 오르지 않으면서 참조함
      - 자신이 참조하던 인스턴스에 nil을 할당할 수 있어야하기 때문에 항상 옵셔널 변수로만 선언이 가능하다
    - unowned: rc 증가하지않으면서 참조
      - 그러나 자신이 참조하는 인스턴스가 항상 메모리에 남아있을 것이라는 전제를 기반으로 동작
      - 자신이 참조하는 인스턴스가 메모리에서 해제되더라도 스스로 nil을 할당하지 않음 > 옵셔널 변수가 아니어도 됨
      - 그러나 미소유 참조를 하면서 메모리에서 해제된 인스턴스에 접근하려한다면 런타임에러를 발생시킴
      - 미소유 참조는 참조를 하는 동안 메모리에서 해제되지 않을 것이라는 확신이 있을 때 사용
    - unowned와 weak의 차이
      - 둘다 참조를 할때 rc가 증가되지 않는다는 공통점이 있음
      - 그러나 weak는 자신이 참조하던 인스턴스에 nil을 할당할 수 있어야 하기 때문에 항상 옵셔널 변수여야 하지만
      - unowned는 자신이 참조하는 인스턴스가 메모리에 해제되더라도 nil을 할당하지 않음
    - 강한 순환 참조는 어떨때에 발생하는가: 각각의 인스턴스가 서로를 꽉 잡고 있어서 rc가 계속 남아있는 경우
      - person과 room class 예시를 생각하자


- safeArea: 콘텐츠가 상태바, 네이게이션 영역, 탭바, 툴바 영역을 가리는 것을 방지하는 영역

- bounds와 frame의 차이
  - bounds: 자신(해당뷰)의 좌표계 기준
  - frame: 슈퍼뷰 기준의 좌표

- 실제 디바이스의 유무에 따라 개발환경에서 할 수 있는 것과 없는 것: 카메라, 생체인식, 블루투스, 오디오 입력, 푸시알림  

- scene delegate: 제일 먼저 보일 뷰에 대한 것을 정해주듯, uiviewlifecycle을 관리해줌
- app delegate
  - 앱의 가장 중요한 데이터 구조를 초기화하는 것 / 앱 자체를 타겟으로 하는 코드를 관리
  - 앱의 scene을 환경설정(Configuration)하는 것
  - 앱 밖에서 발생한 알림(배터리 부족, 다운로드 완료 등)에 대응하는 것
  - 특정한 scenes, views, view controllers에 한정되지 않고 앱 자체를 타겟하는 이벤트에 대응하는 것.
  - 애플 푸쉬 알림 서비스와 같이 실행시 요구되는 모든 서비스를 등록하는것.
    - UIWindow 역할 : 사용자에게 보여질 컨텐츠를 시각적이 아닌 기능적으로 담음(관계 정의같은)

- 앱이 in active 되는 시나리오  
  - 네이버에서 기사를 읽고 이를 카카오톡으로 공유한다고 할때, 공유하기 버튼을 누르면 카카오톡 앱이 active상태가 되고 네이버 앱은 in-active 상태가 된다.

- App LifeCycle
  - not running: 앱이 실행되지 않았거나 종료됨
  - in-active: 앱이 foreground에서 머물지만 아직 실행되지는 않음(이벤트를 받지못함) 이 상태에서 바로 다른 상태로 전이됨
  - active: 앱이 실행된 상태이며 이벤트를 받을 수 있음
  - background: 앱이 background에서 코드를 실행중. (은행앱처럼 추가시간을 요청하는 앱은 이 상태에 머물수 있다) > background에서도 실행되는앱(음악앱)
  - suspended: 앱이 background에 있지만 코드를 실행하지 않음. 일시중지 된 앱은 아직 메모리에 남아있으며, 메모리가 부족해지면 예고없이 해당 앱을 중단시킨다.

- VC LifeCycle
  - viewDidLoad: 뷰가 메모리에 로드된 직후 호출 > 초기화 할 코드를 작성해줌. 초기 한번만 로드 됨
  - viewWillAppear: 뷰가 보여지기 직전에 호출 > 다른뷰로 갔다 돌아올때마다 호출되기에 화면 나타날때마다 수행할 작업 작성
  - viewDidAppear: 뷰가 보여진 다음에 호출 > 뷰가 나타났다는것을 컨트롤러에게 알리는 역할
  - viewWillDisAppear: 뷰가 사라지기 직전에 호출 혹은 다른 뷰로 넘어가지 직전에 호출됨
  - viewDidDisAppear: 뷰가 사라지고 호출 > 화면에 사라지면 필요없어지는 작업들을 진행

- 비동기 프로그래밍: 프로그램의 주 실행흐름을 멈춰서 기다리지 않고 다음 작업을 실행할수 있게 하는 방식
  - 동시성 프로그래밍: 동시에 실행되는 것처럼 보이게 하는 방식
  - 병렬성 프로그래밍: 물리적으로 정확히 동시에 실행시키는 방식

- 동시성 vs 병렬성
  - 동시성: 한명이 번갈아가며 처리
  - 병렬성: N:N

- NSOperationQueue와 GCD Queue의 차이
  - OperationQueue: 비동기적으로 실행되어야 하는 작업을 객체 지향적인 방법으로 사용 > 어떤 작업이 완벽하게 마무리 되어야 그 다음작업으로 넘어가짐(작업간 의존성 높음) > KVO가능
  - GCDQueue: 메인과 백그라운드에서 동기/비동기 모두 가능 > KVO 불가능
    - Serial Dispatch Queue: 등록된 작업을 한번에 하나씩 차례대로 처리 한다. 처리중인 작업이 완료되면 다음 작업을 처리!
    - Concurrent Dispatch Queue: Concurrent Queue는 등록된 작업을 한번에 하나씩 처리 하지 않고 여러 작업들을 동시에 처리
    - global: Concurrent Queue로 Global Queue는 처리 우선 순위를 위한 qos(Quality of service) 파라메터를 제공하여 병렬적으로 동시에 처리를 하기때문에 작업 완료의 순서는 정할수 없지만 우선적으로 일을 처리하게 할수 있다.
    - main: Serial Dispatch Queue로 모든 UI 처리는 메인 스레드에서 처리 > 동기 실행하면 교착상태 발생
    - sync: 동기
    - async: 비동기

- GCD API 동작방식과 필요성
  - 필요성: 보통 스레드 처리를 하는 작업들은 시간이 꽤나 걸리는 큰 작업이거나 언제 끝날지 알수 없는 작업에 사용 되는데 (ex: 네트워크, 파일로딩) 작업이 처리 되는동안 아무것도 하지 못하고 멈춰 있으면앱이 렉이 걸리거나 아무 반응이 없는거처럼 보인다. 그래서 보통 동기 처리 메소드인 sync는 잘 사용하지 않는다.

- Global DispatchQueue의 Qos 종류와 각각 어떤 의미
  - userInteractive : 중요도가 높고 즉각적인 반응이 요구되는 작업으로 즉각적으로 작업이 처리됩니다. UI업데이트나 이벤트 핸들링 등에 사용됩니다.
  - userInitiated : 빠른 결과를 기대할 때 사용하는 QoS
  - utility : 계산, I/O, 네트워킹 등 시간이 다소 오래 걸리는 작업입니다.
  - background : 유저가 인지하지도 못하는 뒷단에서 실행되는 작업입니다.

- Custom View를 만드는 방법 → 프로젝트 예시 들면서 :
  - 일반 셀들은 register로 연결
  - panel 같은 경우는 panel 파일내 백그라운드로 만들어질 뷰를 생성 후 addsubview해서 생성
  - 공통적으로 사용될 셀이나 뷰를 재사용 하기 위해 생성

- UIView에서 Layer는 무엇이고, 어떤 역할
    - UIView에서 이벤트가 발생했을 때 뷰 위에 컨텐츠나 애니메이션를 그리는 행위를 UIKit에서 CoreAnimation으로 위임해 CALayer가 담당
    - view를 쌓아서 올리는것보다 layer를 쌓아서 올리는 것이 퍼포먼스 측면에서 볼때 훨씬 이득

- App Bundle 구조와 역할 :
- 앱 화면 콘텐츠를 표시하는 로직과 관리를 담당하는 객체 : UIView, UIContoller
- 앱 콘텐츠나 데이터 자체를 저장/보관하는 특별한 객체 : 아카이빙(NSCoding), UserDefaults


---

- Git의 장점: 파일의 변화를 시간에 따라 기록이 가능해 관리가 가능하다. & 브랜치(병렬개발가능)

- Rest API: 서버와 클라이언트가 http method를 통해 데이터를 주고받는 방식
  - post: 리소스 생성
  - get: 리소스 읽어오기
  - put: 리소스 수정
    - patch: put은 리소스 전체를 수정, patch는 일부를 변경 따라서 update의 의미에서는 patch가 더 적절
  - delete: 리소스 삭제

- 상태코드
  - 200: 성공
  - 300: 리다이렉션(클라이언트에 요청에 대해 적절한 다른 위치를 제공하거나, 대안의 응답을 제공한다)
  - 400: 클라이언트 에러
  - 500: 서버에러

- Garbage Collection: 클래스로부터 필요에 따라 만든 객체가 더이상 필요 없어졌을 때(사용되지 않을 때), 회수하는 역할. 즉 메모리에서 날려버림으로써 메모리를 여유롭게 만들어준다. (임자없는 객체를 회수하는 역할)
- Cache: 캐싱은 영어 단어 뜻대로 저장하는 것이다. 좀 더 자세하게 설명하자면 오래걸리는 작업을 저장해두었다가 동일한 작업을 수행해야할 때 저장된 결과를 가져와서 사용하는 것을 의미

- PNG와 JPG의 차이 :
- Dynamic Programming :
- Virtual Memory :
- Database Index 추가의 장단점 :
- HDD, SSD, DRAM 각각의 성능 :

---
- process와 thread 비교 설명
  - 프로그램: 보조기억장치에 저장되어있는 실행코드
  - 프로세스: 프로그램을 실행시켜 메모리 상에서 실행되는 작업상태
  - 스레드: 프로세스 내에서 실행되는 작업흐름의 단위
  - 멀티프로세스: 보통 하나의 프로세스안에 하나의 스레드가 가지고 있지만, 환경에 따라 둘 이상의 스레드를 동시에 실행하는 것

- multi thread 환경 장단점
  - 장점: 여러개의 실행흐름을 가져갈 수 있음
  - 단점: 쓰레드는 프로세스처럼 완전히 독립적인 구조가 아니기에 환경적으로 쓰레드 사이에 공유하는 구간이 있다.
    - 이미 사용중인 자원에 접근했을 때 엉뚱한 값을 불러올수도 있거나 병목현상이 발생해 시스템 성능이 저하될 수 있음


- DFS와 BFS란?
    - 그 외의 그래프 탐색 방법?
- Array와 Linked List란?
- Hash란?
- quick sort :


### 프로젝트 관련

- 비캠퍼스
- 모플
- 술술
    - SDWebImage와 Kingfisher의 차이 :
    - MVVM과 MVC :

### 창의수학

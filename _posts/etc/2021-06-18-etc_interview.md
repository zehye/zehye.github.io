---
layout: post
title: iOS 개발자로 취업하기 > Interview 준비
category: etc
tags: [etc]
comments: true
---

> iOS 개발자로서 취업준비를 하면서 정리해본 면접 질문지 입니다.     
잘못된 내용이 있거나 추가하면 좋을 내용이 있다면 언제든지 댓글 남겨주세요 :)

<hr>

아오스 개발자가 되기 위해서는 코딩실력도 있어야하지만, 우선 취업을 하기 위해 면접을 거치겠쥬..?<br>
면접에 대비하기 위해 면접 질문을 긁어 보았습니다.

[이전에 작성했던 질문지](https://github.com/zehye/ios_Interview)는 요기에! <br>
실제 면접에서 받은 질문도 정리해보았고, 면접을 준비하면서 실제 면접 본 사람들에게 받은 질문지를 싹싹 긁어 놓은것이라 위 깃헙에 정리해 놓은 글은 아오스 개발자만이 아닌 웹 백엔드 개발자의 질문도 간간히 들어가있다는것을 참고해주세요.

> 아래부터는 질문 뿐만이 아니라, 공부하고 느낀것을 토대로 간단히 작성해보았습니다.


### 공통적으로 생각해보면 좋은 질문

- 1분 자기소개
  - 안녕하세요. 이번에 ios 직무에 지원하게 된 xxx입니다. 개발자로서 가장 중요한 두 가지 역량을 꼽는다면 목표를 달성하는 집요함과 배움에 대한 두려움이 없는 용기라고 생각합니다. 처음 대외활동을 통해 개발공부를 하게 된 경험 이래로 개발에 관심을 갖게 되어 IT 연합 동아리에 지원을 하였고 더 많은 역량을 키우기 위해 스스로 외부 스터디를 만들어 팀원들을 모아 공부하고 프로젝트를 진행하였습니다. 비록 비전공자이지만 여러 수업을 자기주도적으로 찾아 들으며 찾은 지식들은 운영하고있는 블로그에 정리함으로써 공부한것을 정리하고 많은 사람들에게 공유하고 있습니다. 비록 소소한 성장과 성취이겠지만, 끊임없이 성장하기 위해 많은 노력과 시도를 하고 있다고 생각합니다. 앞으로도 끊임없이 시도하고 도전함으로써 집요함과 성실함을 바탕으로 일하는 개발자가 되고 싶습니다. 감사합니다.

- 코딩 왜 시작했냐
  - 처음 개발자를 접하게 된건 대외활동에서 코딩 교육을 받으면서 시작되었음. 교육을 통해서 문제가 발생하면 이를 분석해 스스로 해결하고 그에 대한 결과물이 바로바로 도출된다는 점에서 매력을 느낌.
  - 기존 전공과의 차이에서는 공부한만큼 언젠가는 성장을 느낄수 있고, 그리고 정답이라는게 언제나 존재하고, 그 정답을 효율과 합리 안에서 더 나은 정답을 만들어나가야 하는 부분이 매력적으로 느껴짐
  - 다른 언어에 비해서 진입장벽이 높다는 부분도 매력적이었으며, 내가 만들어낸 코드가 시각적으로 보여지는 부분도 매력적

- 나의 장 단점
  - 장점: 배운건 바로 정리하고 써먹음 > 플로팅 패널 & 커스텀 패널
  - 단점: 말이 많음 > 대화하는걸 너무..좋아함
  - 늦게 시작한만큼 뒤쳐지지 않겠나? > 장점으로 다시 어필

- 서버에서 클라이언트 변화이유
  - 서버에서 느낀점과 클라이언트에서의 차이점
    - 변화하고 새로운것을 공부하는 것을 좋아하는데, 스스로 감히(?) 생각해본 서버라는 분야는 이미 오랫동안 많은 사람들에게 개발이 된 언어여서 언어 자체의 안정성이 높아 업데이트의 속도나 변화가 그다지 크다고 느껴지지 않음. 특히 swift라는 언어는 다른 언어에 비해 만들어진지 오래 되지 않았고, 다른 언어나 프레임워크에 비해 발전의 속도가 빠르고 매해 매 순간 공부하고 새롭게 다져넣어야 하는 기능들이 많다고 생각함. 앞으로 배울 것이 많다는 점에서 선택하게 되었음
  - 더 나아가 서버에 비해 클라이언트는 한눈에 내가 한 부분이 보여지고 내가 적용해놓은 기능을 유저가 직접적으로 보고 사용한다는 점이 매력적

- 지원동기
  - 당사 서비스에 대한 관심

- 흥미롭게 본 오픈소스 라이브러리가 무엇
  - alamofire > 모플 하면서
  - swfitsoup > 쿠킹덤 쿠폰번호 긁어오면서 사용해봄
    - 서버에서 데이터를 보내주는데 시간이 오래걸리게 되어서, 우선적으로 데이터를 뽑아 넣어보기 위해 사용해봄

- 최근 겪은 기술적 어려움은 무엇이고 어떻게 해결했느냐
  - 라이브러리와 연결지어서 생각했음
  - 최근 alamofire를 사용하면서 애먹은 기억이 있어서 그걸 살림
    - 디버깅을 통해 response 데이터를 분석하고 에러코드 확인, 바디로부터 뭐가 넘어오는 지 확인
    - 공통된 api가 있었는데, 하나의 api에서는 단순히 get을 통해 데이터를 불러오는 역할을 했었고, 하나는 patch를 통해 데이터를 수정하는 것
    - 넘어오는 필수 파라미터 처리를 제대로 하지 않았는데, 이에 대한 문제 해결을 하기 위해 response 데이터를 디버깅 통해 확인
    - 필수 바디가 담겨있지 않음을 확인했고, 에러코드 통해 서버가 아닌 클라이언트 문제였음을 확인
    - 처음에는 단순히 데이터가 변경되지 않아 서버측에 api 확인 요청만을 드렸는데, 결과적으로 내 잘못이라는것을 확인
    - 이후에는 좀더 내 선에서 확인할 수 있는 부분을 최대한으로 확인하려하고, 잘 모르는 부분 혹은 이걸 물어봐도 되는지에 대한 모호성이 존재한다면 우선적으로 시니어 개발자분께 여쭤봄으로써 이걸 내가 질문을 해도 되는건지, 좀더 내 선에서 확인할 수 있는 부분은 어떻게 해야하는지 등을 물어본 뒤 그럼에도 해결되지 않고 확실하게 클라이언트 측의 문제가 아니라는 확신이 든다면 '어떤 부분에서 어떤 문제가 일어나는데 나는 이런부분을 확인해보았고 그럼에도 이런 결과가 나와 요청을 드린다.'라는 부분으로 명확한 커뮤니케이션을 할 수 있도록 해야겠다고 생각함

- 문제 해결에 오랜시간이 걸릴경우 이를 어떻게 해결할 것인가
  - 듀를 조금더 세부적으로 끊어서 사고하려하기
  - 작은 성취들을 만들어 멘탈관리를 하고 그럼에도 해결되지 않을때는 도움요청

- 커리어 골 / 10년 뒤 달성하고자 하는 목표
  - 제가 지금까지 ios 공부를 하면서 제일 제게 큰 영향을 이끈 분이 한분 계시는데, 그 분을 통해서 조금 더 빠르게 성장할 수 있었고 빠르게 배울 수 있었다. 나 또한 한명의 시니어 개발자가 됨으로써 많은 후배 개발자들이 포기하지않고 끝까지 개발에 흥미를 가질 수 있게 하는 그런 영향을 끼칠 수 있는 개발자가 되고 싶다.
- 이회사는 당신의 목표에 얼마나 도움이 될것인가
- 회사에 원하는 것
  - 매니징이 아닌 계속해서 개발을 할 수 있도록 하면 좋겠다.
- 하고싶은 질문
  - 개발자가 몇명인지? = 사수의 유무
  - 앞으로 기술 스택의 변화는 어찌될지?


### swift / iOS

- **Swift 특징**
  - 안전성(guard구문, 오류처리, 강력한 타입통제)
  - 신속성(설계를 성능을 최대한 C언어에 가깝게 맞춤)
  - 더 나은 표현성(그간 발전된 프로그래밍 언어를 모두 참고하여 사용하기 편하고 보기좋은 문법을 구사하려 노력)

- 옵젝씨와 스위프트 차이 : 포인터 유무, 옵셔널 유무, 브릿지 파일의 유무(헤더파일, 스크립트 파일로 나뉘어 사용하다가 이제는 swift 파일 하나로)

- **Closure**: 이름없는 함수, 파라미터와 반환타입을 생략해 코드를 축약할 수 있음, 클래스처럼 참조타입이다(상수에 클로저를 할당을 해도 값이 변할수있다)
  - okhandler> 상수를 선언했어도 okhandler를 사용하게되면 그 값이 변함

- **let과 var의 차이**
  - let: 상수, 상수 선언시 값 변경 불가능
  - var: 변수, 변수 선언시 값 변경 가능

- **AutoLayout의 장단점**
  - 장점: 인터페이스의 절대적인 좌표가 아닌 동적인 상대적인 좌표가 필요할때 유용
  - 단점:

- **LayoutSubViews**
  - 뷰와 서브뷰의 위치와 크기 재조정
  - vc 내 뷰가 재계산되서 다시 그려질 때 호출됨 →
  - 뷰의 값이 갱신되고, vc의 `viewDidLayoutSubViews` 호출 → 뷰 값에 의존하는 행위는 모두  `viewDidLayoutSubViews`에 구현해야함
  - 뷰 크기 조절, 서브뷰 추가, 스크롤뷰를 스크롤할 때, 디바이스 회전, 뷰의 contraint 값 변경했을 때 자동 호출
  - **LayoutSubViews를 수동적으로 예약하는 기능** : `setNeedsLayout`
  - **setNeedsLayout을 통해 LayoutSubViews를 예약호출하는 것 말고, 자동으로 더 빨리 호출되는 기능** : `layoutIfNeeded`

- 스토리 보드의 장단점
  - 장점: 시각화, 시간절약, 낮은 진입장벽
  - 단점: 로딩시간 오래걸림(앱이 무거워짐), 협업할때 변화에 대한 추적이 어렵다, merge의 어려움
  - 뷰 생성시 시간절약, 시각화되어 흐름을 한눈에 볼수 있으며 낮은 진입장벽이라는 장점이 있지만 **스토리보드 로딩시간이 길어지면 생산성 저하, 가독성 저하, 협업시 변화 사항에 대한 추적이 어렵고 충돌 발생 소지가 아주 높으며 머지 컨플릭트 해결이 어려움, 뷰의 재사용 어려움, 뷰와 코드의 연결을 위해선 identifier를 계속 부여해야 함**

- **MVC 패턴**(각 역할과 흐름)
  - model: 로직을 구현하는 부분
  - view: 화면에 보여질 부분(ui관련된 것들만 담는다)
  - controller: 모델을 해석해 뷰에게 보내줌

- model > view: 소통못함
  - model은 ui와 독립적이지만 view는 ui에 의존 & view는 일반객체로 버튼 자체가 무엇을하는 지는 모름
- model > controller: 소통은 가능함
  - model의 데이터가 변경되는 경우 KVO, Notification을 통해 소통이 가능하긴 함
- controller > model: 소통 가능
  - controller는 model의 모든 기능과 소통이 가능 > 무엇을 어떻게 보여질지에 대한 부분이기에
- controller > view: 소통 가능
  - outlet을 통해 무한한 대화가 가능
- view > controller: 소통은 가능함
  - delegate, dataSource를 통해 가능 & target-action

- MVVM: Model-View-ViewModel
  - 객체가 독립적이라 자동화테스트에 용이, 유지보수가 좋음
  - model: 로직을 구현하는 부분
  - view: 화면에 데이터가 뿌려지는 부분
  - viewmodel: model로부터 데이터를 가져오는 부분  
  - `View`에서 사용자 액션이 발생하면 `ViewModel`이 `Model`에게 데이터 요청하고 `Model`이 업데이트한 데이터를 다시 `ViewModel`에 전달하면 그 데이터를 기반으로 `View` 업데이트
  - **설계가 어렵고 View에 대한 처리가 복잡할수록 ViewModel이 거대해지지만**
  - **유지보수에 용이하고 각 객체가 독립적이기 때문에 자동화 테스트에 적합함**

- **Delegate와 Notification의 차이**
    - **Delegate**
      - 프로토콜을 통해 정의
      - 로직의 흐름을 따라가기 쉬움
      - delegate안에 nil이 할당되지 않게 주의
      - 많은 객체들에게 이벤트를 알려주기 어려움
    - **Notification**
      - Notification center 라는 싱글턴 객체를 통해 옵저버를 등록한 객체게에 Notification post를 하는 방식
      - 다수의 객체들에게 동시에 이벤트 발생을 알려줄 수 있음
      - 추적이 쉽지 않음

- Singleton패턴: 특정 클래스의 인스턴스가 오직 하나임을 보장하는 객체
  - UserDefaults, NotificationCenter, UIApplication, FileManager, URLSession

- KVC와 KVO란(동작방식)
  - KVO: 특정 키의 값 변화를 감지하기 위한 기능 > `@objc dynamic`

- willset, didset: 프로퍼티의 값이 변경되기 전, 후를 감지하여 그때 원하는 작업을 수행할 수 있다.
  - willset: 프로퍼티의 값이 변경된 직후를 감지
  - didset: 프로퍼티의 값이 변경되지 직전을 감지

- willset, didset과 KVO의 차이
  - 우리가 타입을 만드는 경우에는 willset, didset을 자유롭게 구현이 가능하겠지만, 외부 라이브러리 혹은 다른 사람이 구현한 타입이라면 이를 내부에서 마음대로 작업할수는 없을것. 따라서 이런때 타입의 프로퍼티들이 변경되는지에 대한 확인은 KVO로 관찰할 수 있다. 따라서 KVO는 상속이나 코드의 변경없이 옵저빙할수 있다.

- ios에서 https를 더 지향하는 이유: 사용자 정보보호에 대한 중요성 대두

- http도 허용되는 예외상황
  - 로컬 네트워크에 연결할때
  - webkit을 통한 콘텐츠 요청할때
  - AVFoundation 프레임워크를 통한 스트리밍 서비스를 할때

- Optional
    - 왜 필요한가: 변수안에 값이 있을지 없을지 확실하지 않을때 사용
      - 기본적으로 변수에 값을 할당할때 반드시 non-Optional한 값을 넣어줘야한다.
      - nil은 어떠한 값도 아니다.
      - safe, fast, expressive
    - ?와 !
      - ?: 값을 가지고 있다면 값을 반환해주고 없다면 nil을 반환(nil도 메모리는 차지하고 있음)
      - !: 강제 언래핑, 상자 안에 값이 있든 없든 가지고 옴 > nil이 아닐거라고 확신할때 사용해야함
    - 옵셔널 타입의 변수를 가져오는 방법
      - 옵셔널 바이닝: if let > 값이 nil인지 아닌지에 따라 결과를 달리하고 싶을 때 사용
      - 옵셔널 체이닝: ?.?. > 하위 프로퍼티 값으로 옵셔널 값이 있는지 없는지 계속 확인하면서 파고 들어가는 방법
        - 중간에 하나라도 nil이 있다면 nil을 반환해준다
    - 안전한 ? 아닌 !을 사용하는 이유: 값이 있다는것을 확신할때 사용

- Class/Struct/Enum
    - 값타입과 참조타입
      - 값타입: 데이터 전달 시 값을 복사해서 전달
      - 참조타입: 값의 메모리 위치를 전달
    - class: 참조타입, 상속 가능, deinit을 통해 메모리 해제가 가능하다.
    - struct : 값 타입, 상속 불가능
        - **class와 struct 사용 기준 : 참조가 아닌 복사를 원할때, 상속이 불필요할때**
    - enum: 값 타입, 상속 불가능


- instance method와 type method의 차이: 인스턴스 메소드는 특정 타입의 인스턴스화를 통해 호출할 수 있으나, 타입 메소드는 인스턴스화없이 타입 객체 자체를 통해 호출 가능
  - class type method : 클래스에서만 구현 가능, 재정의 가능
  - static type method : 기본

- 프로토콜: 특정 작업이나 기능에 맞게 메소드, 프로퍼티 등을 정의한 약속/규약, 프로토콜 내에선 정의만 하고 구현은 해당 프로토콜을 채택하는 곳에서 함
  - TableViewCell, VC에서 pop할 때 데이터도 같이 넘길 수 있음
- Extension: 기존의 클래스/구조체/열거형에 기능을 추가 확장시키는 것, 기존 기능 재정의는 불가능, convenience init 추가 가능

- Hashable은 무엇이고, 왜 Equatable을 상속하는가?
- mutataing :

- **접근 제어자 종류** : 데이터 은닉화. 코드의 세부 구현사항을 숨기고 접근 하는 것에 있어 제한을 둘수있음
  - open: 외부의 다른 모듈에서 import 가능, import한 모듈에서 subclass, override 가능
  - public: 외부의 다른 모듈에서 import 가능, import한 모듈에서 subclass, override 불가능
  - internal: 자신의 모듈 내에서만 접근 가능 > 프로젝트 내부용
  - fileprivate: .swift 파일 안에서만 접근 가능 > 같은 소스 파일 안에서만 접근 가능
  - private: 함수안에서 선언하면 그 함수 안에서만 접근 가능

- defer: 현재의 코드 블럭을 나가기 전에 꼭 실행해야하는 코드를 작성하여 반드시 작업하도록 도와주는 함수
    - defer 호출 순서: 선언된 역순으로 진행
    - defer 호출되지 않는 경우 :

- 생성자(designated/convenience/required) 차이
  - designated: 초기화 이니셜 라이저. 모든 프로퍼티들이 초기화될 수 있도록 해준다. 따라서 모든 클래스는 하나 이상의 designated init을 가진다.
  - convenience: 보조 이니셜 라이저. 기본적으로 designated init이 선언되어야 사용할 수 있다.
  - 둘 사용의 기준점: convenience init는 init에서 지정한 파라미터 외의 값을 받고자 할 때 사용 + 사용자 정의로 값을 변형해서 저장하고자 할 때 사용, init을 먼저 구현해줘야 구현할 수 있고 `self.init`을 호출해줘야 함
  - required: 모든 서브 클래스에서 반드시 재정의해야하는 init, 상속이 기본적으로 포함 → 상속할 수도 있는 클래스에선 포함 유무를 고민해야 함

- **OOP와 POP**
    - OOP: 캡슐화(정보은닉), 상속가능, 추상화(필요한 정보만을 중심으로 간소화하는 것 - 객체간의 공통적인 속성과 기능으로 추상화), 다형성(재정의를 통해 다른 방식의 코드를 실행할 수 있도록 하는 것>override, overloading - 형태가 같은데 다른 기능을 하는 것을 의미한다 (같은 동작이지만 다른 결과물이 나올때 다형이라고 생각하면 된다))
    - POP: 확장성(수평적인 기능확장), 상속가능, 안정성:클래스를 통해 기능적으로 하나의 원본을 여러군데에서 사용해야하는 경우도 있지만, 멀티쓰레드 환경에서는 한 원본을 두고 여러작업이 동시에 진행되게 되면 원본 데이터가 꼬일 가능성이 크기때문에 하나의 원본으로 작업해야할 필요가 없다면 가급적으로 값 타입인 구조체나 열거형을 사용하는 것을 권장한다. + 값: 메모리 추적이 간편

- 고차함수
    - sort/sorted: 값을 정렬 > sort: 원본에 영향줌, sorted: 원본에 영향 안줌
    - filter: 필터된 값을 반환
    - reduce: 초기값이 있고 초기값과 첫번째 요소 ~ 끝번째 요소까지의 실행된 최종 결과값만을 반환
    - map: 값을 변경하되 이를 반환받을때 배열로 받음
    - compactMap: 옵셔널이 포함된 배열안에 nil을 제거하고 옵셔널 바인딩을 하고싶을 때 사용(+ 값의 변형도 가능) → 새로운 배열 반환

- ARC
    - 메모리 사용을 관리하고 추적하기 위해 사용
    - GC와의 차이점: ARC는 컴파일시 실행, GC는 프로그램 동작 중 실행
    - Retain Count(=reference count)
      - 할당: 값을 변수에 할당할때 증가
      - 해제: 변수 생명주기가 끝나거나 nil이 할당되거나 인스턴스가 메모리에서 해체될때
    - strong: 변수가 할당되면 rc+1 > 인스턴스가 계속해서 메모리에 남아있어야하는 경우 사용
    - weak: 변수가 할당되어도 rc 오르지 않으면서 참조함
      - 자신이 참조하던 인스턴스에 nil을 할당할 수 있어야하기 때문에 항상 옵셔널 변수로만 선언이 가능하다
    - unowned: rc 증가하지않으면서 참조
      - 그러나 자신이 참조하는 인스턴스가 항상 메모리에 남아있을 것이라는 전제를 기반으로 동작
      - 자신이 참조하는 인스턴스가 메모리에서 해제되더라도 스스로 nil을 할당하지 않음 > 옵셔널 변수가 아니어도 됨
      - 그러나 미소유 참조를 하면서 메모리에서 해제된 인스턴스에 접근하려한다면 런타임에러를 발생시킴
      - 미소유 참조는 참조를 하는 동안 메모리에서 해제되지 않을 것이라는 확신이 있을 때 사용
    - unowned와 weak의 차이
      - 둘다 참조를 할때 rc가 증가되지 않는다는 공통점이 있음
      - 그러나 weak는 자신이 참조하던 인스턴스에 nil을 할당할 수 있어야 하기 때문에 항상 옵셔널 변수여야 하지만
      - unowned는 자신이 참조하는 인스턴스가 메모리에 해제되더라도 nil을 할당하지 않음
    - 강한 순환 참조는 어떨때에 발생하는가: 각각의 인스턴스가 서로를 꽉 잡고 있어서 rc가 계속 남아있는 경우
      - person과 room class 예시를 생각하자
      - Delegate retain되는지 안되는지 : 된다!
      - a뷰컨의 delegate를 b뷰컨에서 위임받고 b뷰컨을 c뷰컨에서 객체를 갖고 있을 때, c뷰컨에서 b뷰컨 객체에 nil을 할당한다면 a뷰컨의 delegate와 b뷰컨은 계속해서 강한 참조를 하게되며 **결국 메모리 누수가 발생할 것이다(= retain cycle 발생)**


- safeArea: 콘텐츠가 상태바, 네이게이션 영역, 탭바, 툴바 영역을 가리는 것을 방지하는 영역

- bounds와 frame의 차이
  - bounds: 자신(해당뷰)의 좌표계 기준
  - frame: 슈퍼뷰 기준의 좌표

- 실제 디바이스의 유무에 따라 개발환경에서 할 수 있는 것과 없는 것: 카메라, 생체인식, 블루투스, 오디오 입력, 푸시알림  

- scene delegate: 제일 먼저 보일 뷰에 대한 것을 정해주듯, uiviewlifecycle을 관리해줌
- app delegate
  - 앱의 가장 중요한 데이터 구조를 초기화하는 것 / 앱 자체를 타겟으로 하는 코드를 관리
  - 앱의 scene을 환경설정(Configuration)하는 것
  - 앱 밖에서 발생한 알림(배터리 부족, 다운로드 완료 등)에 대응하는 것
  - 특정한 scenes, views, view controllers에 한정되지 않고 앱 자체를 타겟하는 이벤트에 대응하는 것.
  - 애플 푸쉬 알림 서비스와 같이 실행시 요구되는 모든 서비스를 등록하는것.
    - UIWindow 역할 : 사용자에게 보여질 컨텐츠를 시각적이 아닌 기능적으로 담음(관계 정의같은)

- 앱이 in active 되는 시나리오  
  - 네이버에서 기사를 읽고 이를 카카오톡으로 공유한다고 할때, 공유하기 버튼을 누르면 카카오톡 앱이 active상태가 되고 네이버 앱은 in-active 상태가 된다.

- App LifeCycle
  - not running: 앱이 실행되지 않았거나 종료됨
  - in-active: 앱이 foreground에서 머물지만 아직 실행되지는 않음(이벤트를 받지못함) 이 상태에서 바로 다른 상태로 전이됨
  - active: 앱이 실행된 상태이며 이벤트를 받을 수 있음
  - background: 앱이 background에서 코드를 실행중. (은행앱처럼 추가시간을 요청하는 앱은 이 상태에 머물수 있다) > background에서도 실행되는앱(음악앱)
  - suspended: 앱이 background에 있지만 코드를 실행하지 않음. 일시중지 된 앱은 아직 메모리에 남아있으며, 메모리가 부족해지면 예고없이 해당 앱을 중단시킨다.

- VC LifeCycle
  - viewDidLoad: 뷰가 메모리에 로드된 직후 호출 > 초기화 할 코드를 작성해줌. 초기 한번만 로드 됨
  - viewWillAppear: 뷰가 보여지기 직전에 호출 > 다른뷰로 갔다 돌아올때마다 호출되기에 화면 나타날때마다 수행할 작업 작성
  - viewDidAppear: 뷰가 보여진 다음에 호출 > 뷰가 나타났다는것을 컨트롤러에게 알리는 역할
  - viewWillDisAppear: 뷰가 사라지기 직전에 호출 혹은 다른 뷰로 넘어가지 직전에 호출됨
  - viewDidDisAppear: 뷰가 사라지고 호출 > 화면에 사라지면 필요없어지는 작업들을 진행

- 비동기 프로그래밍: 프로그램의 주 실행흐름을 멈춰서 기다리지 않고 다음 작업을 실행할수 있게 하는 방식
  - 동시성 프로그래밍: 동시에 실행되는 것처럼 보이게 하는 방식
  - 병렬성 프로그래밍: 물리적으로 정확히 동시에 실행시키는 방식

- 동시성 vs 병렬성
  - 동시성: 한명이 번갈아가며 처리
  - 병렬성: N:N

- NSOperationQueue와 GCD Queue의 차이
  - OperationQueue: 비동기적으로 실행되어야 하는 작업을 객체 지향적인 방법으로 사용 > 어떤 작업이 완벽하게 마무리 되어야 그 다음작업으로 넘어가짐(작업간 의존성 높음) > KVO가능
  - GCDQueue: 메인과 백그라운드에서 동기/비동기 모두 가능 > KVO 불가능
    - Serial Dispatch Queue: 등록된 작업을 한번에 하나씩 차례대로 처리 한다. 처리중인 작업이 완료되면 다음 작업을 처리!
    - Concurrent Dispatch Queue: Concurrent Queue는 등록된 작업을 한번에 하나씩 처리 하지 않고 여러 작업들을 동시에 처리
    - global: Concurrent Queue로 Global Queue는 처리 우선 순위를 위한 qos(Quality of service) 파라메터를 제공하여 병렬적으로 동시에 처리를 하기때문에 작업 완료의 순서는 정할수 없지만 우선적으로 일을 처리하게 할수 있다.
    - main: Serial Dispatch Queue로 모든 UI 처리는 메인 스레드에서 처리 > 동기 실행하면 교착상태 발생
    - sync: 동기
    - async: 비동기

- GCD API 동작방식과 필요성
  - 필요성: 보통 스레드 처리를 하는 작업들은 시간이 꽤나 걸리는 큰 작업이거나 언제 끝날지 알수 없는 작업에 사용 되는데 (ex: 네트워크, 파일로딩) 작업이 처리 되는동안 아무것도 하지 못하고 멈춰 있으면앱이 렉이 걸리거나 아무 반응이 없는거처럼 보인다. 그래서 보통 동기 처리 메소드인 sync는 잘 사용하지 않는다.

- Global DispatchQueue의 Qos 종류와 각각 어떤 의미
  - userInteractive : 중요도가 높고 즉각적인 반응이 요구되는 작업으로 즉각적으로 작업이 처리됩니다. UI업데이트나 이벤트 핸들링 등에 사용됩니다.
  - userInitiated : 빠른 결과를 기대할 때 사용하는 QoS
  - utility : 계산, I/O, 네트워킹 등 시간이 다소 오래 걸리는 작업입니다.
  - background : 유저가 인지하지도 못하는 뒷단에서 실행되는 작업입니다.

- Custom View를 만드는 방법 → 프로젝트 예시 들면서 :
  - 필요성: 뷰의 재사용 / 여러 뷰에서 재사용되는 cell, 패널/팝업/alert
  - 일반 셀들은 register로 연결
  - panel 같은 경우는 panel 파일내 백그라운드로 만들어질 뷰를 생성 후 addsubview해서 생성
  - 공통적으로 사용될 셀이나 뷰를 재사용 하기 위해 생성
  - 즉, tableview나 collectionview 프로토콜을 슈퍼뷰에 위임할 때 xib 파일로 작성된 cell을 사용한다고 등록하거나, 패널/팝업/alert와 같은 커스텀뷰는 섹션을 구분지어 각 섹션에서 백그라운드가 될 뷰를 만들고 실제 띄워줄 커스텀뷰를 그 위에 서브뷰로 띄움

- UIView에서 Layer는 무엇이고, 어떤 역할
    - UIView에서 이벤트가 발생했을 때 뷰 위에 컨텐츠나 애니메이션를 그리는 행위를 UIKit에서 CoreAnimation으로 위임해 CALayer가 담당
    - view를 쌓아서 올리는것보다 layer를 쌓아서 올리는 것이 퍼포먼스 측면에서 볼때 훨씬 이득

- App Bundle 구조와 역할 :
- 앱 화면 콘텐츠를 표시하는 로직과 관리를 담당하는 객체 : UIView, UIContoller
- 앱 콘텐츠나 데이터 자체를 저장/보관하는 특별한 객체 : 아카이빙(NSCoding), UserDefaults

- **RxSwift** : 데이터의 흐름에 따른 비동기적인 프로그래밍 패러다임을 구체화 시킨 swift용 라이브러리
- **CocoaPod 사용 이유** : 오픈 소스 라이브러리 관리 자동화(버전 업데이트 등) → 시간 절약

- SDWebImage와 Kingfisher의 차이
  - 리사이즈 적용 유무에 따라 나타나는 현상이 다른데, 리사이즈를 적용하지 않았을 땐 kingfisher 의 메모리 사용량이 증가하고 cpu가 튀거나 버벅이는 현상이 발생했다. 그러나 리사이즈를 적용했을 땐 sdwebimage 의 메모리 사용량과 캐싱 타임이 상승했고 메모리와 cpu 튐 현상이 발생했다.

- MVVM과 MVC
  - MVC는 코드량이 적은 편이지만 뷰와 컨트롤러가 밀점하게 연결되어 있어서 유지보수가 어려워 규모가 작은 프로젝트에서만 유용하다. 그러나 MVVM은 설계가 어렵지만 모델과 뷰, 뷰모델이 독립적이라서 유지보수가 쉽고 자동화 테스트에 적합하다.


---

- Git의 장점: 파일의 변화를 시간에 따라 기록이 가능해 관리가 가능하다. & 브랜치(병렬개발가능)

- Git : 로컬 내에서 소스를 관리하는 것 **병렬 개발 가능, 중앙 저장소가 날아가도 원상복구 가능**
- Github : 로컬에서 관리한 소스를 업로드하고 공유할 수 있는 공간

- **프레임워크와 라이브러리 차이**
  - **프레임워크** : 전체적인 흐름을 자체적으로 제어함
  - **라이브러리** : 사용자가 흐름에 대해 제어하고, 필요한 상황에 따라 가져다 씀

- Rest API: 서버와 클라이언트가 http method를 통해 데이터를 주고받는 방식
  - post: 리소스 생성
  - get: 리소스 읽어오기
  - put: 리소스 수정
    - patch: put은 리소스 전체를 수정, patch는 일부를 변경 따라서 update의 의미에서는 patch가 더 적절
  - delete: 리소스 삭제

- 상태코드
  - 200: 성공
  - 300: 리다이렉션(클라이언트에 요청에 대해 적절한 다른 위치를 제공하거나, 대안의 응답을 제공한다)
  - 400: 클라이언트 에러
  - 500: 서버에러

- Garbage Collection: 클래스로부터 필요에 따라 만든 객체가 더이상 필요 없어졌을 때(사용되지 않을 때), 회수하는 역할. 즉 메모리에서 날려버림으로써 메모리를 여유롭게 만들어준다. (임자없는 객체를 회수하는 역할)
- Cache: 캐싱은 영어 단어 뜻대로 저장하는 것이다. 좀 더 자세하게 설명하자면 오래걸리는 작업을 저장해두었다가 동일한 작업을 수행해야할 때 저장된 결과를 가져와서 사용하는 것을 의미

- PNG와 JPG의 차이 :
- Dynamic Programming :
- Virtual Memory :
- Database Index 추가의 장단점 :
- HDD, SSD, DRAM 각각의 성능 :

---
- process와 thread 비교 설명
  - 프로그램: 보조기억장치에 저장되어있는 실행코드
  - 프로세스: 프로그램을 실행시켜 메모리 상에서 실행되는 작업상태
  - 스레드: 프로세스 내에서 실행되는 작업흐름의 단위
  - 멀티프로세스: 보통 하나의 프로세스안에 하나의 스레드가 가지고 있지만, 환경에 따라 둘 이상의 스레드를 동시에 실행하는 것

- multi thread 환경 장단점
  - 장점: 여러개의 실행흐름을 가져갈 수 있음
  - 단점: 쓰레드는 프로세스처럼 완전히 독립적인 구조가 아니기에 환경적으로 쓰레드 사이에 공유하는 구간이 있다.
    - 이미 사용중인 자원에 접근했을 때 엉뚱한 값을 불러올수도 있거나 병목현상이 발생해 시스템 성능이 저하될 수 있음

- **자료구조**
  - **스택** : LIFO
  - **큐** : FIFO
  - **트리** : 정점과 간선을 이용 특수한 그래프, 사이클이 이뤄지지 않고, 계층 데이터를 처리하기에 적합
  - **힙** : 최대값이나 최소값을 찾아내는 연산을 쉽고하고자 고안된 완전이진트리 구조, 최대힙과 최소힙 방식
  - **ArrayList** : 데이터가 순서대로 늘어진 배열 형태, 주로 스택을 구현할 때 사용 → 삭제와 삽입이 필요X
  - **LinkedList** : 자료의 주소값으로 서로 연결된 형태, 주로 큐를 구현할 때 사용 → 삭제와 삽입에 용이

- DFS와 BFS란?
    - 그 외의 그래프 탐색 방법?
- Array와 Linked List란?
- Hash란?
- quick sort :


### 프로젝트 관련

**어떤 프로젝트? 어떤 상황? 그래서 생긴 문제? 문제를 보고 느낀 개선점? 개선방법? 더 보완해야할 점?**

- 술술
  - 주류 구입처 및 주류 관련 정보를 전달해주는 플랫폼
  - ios 시니어 한분과 함께한 프로젝트
  - 앱 내에서 유투브 동영상을 플레이 하는 기능을 구현 > AVkit를 사용
  - 첫 ios 프로젝트로 동영상을 플레이하는 라이브러리 선택부터 어려움을 겪었음.
  - 나름의 기준을 가지고 라이브러리를 선택해야했으며, 초반에는 유투브 관련된 모든 라이브러리를 다 사용해보았으나, 최근 업데이트가 부족하거나 앱이 너무 무거워진다는 단점이 있어 애플에서 제공해주는 AVkit를 선택하게 되었음.
  - 애플에서 제공해주는 라이브러리라는 것에서 안정성이 보장되어 있었고, 문서로 정리되어있는 부분과 단순 동영상을 플레이하고 정리시키는 목적으로만 사용될 것이기 때문에 가볍게 작동되기만 하면 됐음.
  - 기존에 작업하고 있던 어플리케이션에서 한 부분만 급하게 투입되어 작업했지만, 해당 어플리케이션이 실제 앱스토어에 등록이 되어 실제 내가 만든 서비스가 구현되는 것을 볼 수 있었음.

- 비캠퍼스
  - swift 스터디에서 참여한 프로젝트로 멘토와 학생이 과외 혹은 입시 컨설팅을 가르치고 교육할 수 있도록 도와주는 플랫폼이다.
  - 시니어 개발자 1분의 리드하에 진행한 프로젝트로, 다른 포지션 팀원과의 소통은 원활한 편이 아니였으나 디자인과 서버구축이 완료된 상태였기 때문에 별다른 문제없이 진행이 가능했다.
  - 초기에는 스크롤뷰를 이용해 화면을 구현하다가 테이블뷰를 활용해 다양한 뷰를 구현할 수 있다는 것을 깨닫고 이를 활용해서 채팅화면을 구현했음
  - 채팅은 socket이 아닌 alamofire로 서버에 담긴 내용을 가져오는 통신으로 사용했음. 매번 채팅이 발생할때마다 데이터를 긁어와야하는 부담이 있었지만, 이는 추후에 변경될 부분으로 남겨둠.
  - 채팅탭을 선택하면 Notification을 통해 그때마다 chatlist 를 reload 하도록 구현했음.
  - 채팅 시 키보드로 글자를 입력하는 부분에 height를 일정 크키가 지나면 고정될 수 있도록 해달라는 요청을 받았고, 이를 구글링을 통해 text의 max height를 지정해서 제어할 수 있음을 알수 있었음
  - 테이블뷰를 활용하면 더 다양한 뷰와 퍼포먼스를 구현할 수 있다는 것을 알고 테이블뷰를 이용한 더 다양한 퍼포먼스를 구현해보고싶다고 생각했다.

- 모플
  - swift 스터디원과 지인인 다른 포지션분들을 모집해 진행한 프로젝트로, 사이드 프로젝트 플랫폼 서비스이다.
  - ios 3명, 서버 2명, 디자이너 1명, 안드로이드 2명
  - home과 내 모임 화면을 주도적으로 맡았고, 알림 부분은 추후에 맡을 부분으로 현재는 ui 작업과 대략적인 파이어베이스 연동만 되어있음
  - home에서 주요하게 맡은 부분은 회원가입/로그인 유무에 따른 뷰의 차이 & 카카오 adfit 연동 & scpagescroll 라이브러리 사용
  - 내 모임에서 주요하게 맡은 부분은 내모임 리스트와 내모임 디테일 화면 구현과 편집 화면 구현
    - 공유하기/링크 셀 구현을 하는 과정에서 링크 추가를 누르면 새로운 패널이 나오는데
    - 기존 패널을 사용할떄는 단순 리스트를 가져와서 뿌려주는 뷰를 구현하는 것이었다면 해당 패널에서는 키보드를 사용해 직접 사용자가 데이터를 넣어야하는 작업이 필요
    - 키보드가 패널에 들어가게 되니 패널을 불러오는 윈도우 자체에서 키보드를 생성할 수 있도록 해야했고
    - 키보드가 올라가게 됨으로써 해당 패널만 전체 올라왔을때의 크기를 재 설정해야하는 이슈가 발생
    - 따라서 해당 뷰는 패널이 아닌 새로운 뷰컨으로 만들어 제작하는게 더 옳다고 생각했음 > 컨트롤이 더 쉬울거라고 생각
    - 더 나아가 뷰컨을 패널처럼 사용하게 되다보니, 뷰컨이 전체적으로 올라오는 크기가 정해져있었기 때문에 키보드가 위로 올라가고 내려갈때 보통은 뷰컨 혹은 컴포넌트들의 바컴에 constraint를 걸어 얘의 높이를 조절해주어야 했으나, 이 같은 경우에서는 top에도 마찬가지로 constraint를 걸어 각각을 조절해야했음

  - 디테일 뷰에서는 다양한 뷰를 구현해야하는 이슈가 많았음. 커스텀 패널 사용도 많았고, 필요에 따라 재사용 뷰 혹은 커스텀 뷰를 만들어 구현해야했음
  - 커스텀 뷰 제작의 중요성을 알게됨
    - 이전까지는 독립적인 뷰 사용을 하다보니, 다른 팀원들과 공통되는 뷰가 없어서 커스텀 뷰를 만들어 재사용할 뷰를 만들어야하는 생각을 못했는데, 이번에는 앱의 크기 자체가 크고 전체적으로 재사용되는 뷰가 많아서 처음 앱 ui를 짤때 전체적으로 디자인을 확인하며 재사용될 뷰를 생각해 제작해야함을 깨닫게 됨
    - 더 나아가 각각의 기능들이 독립적인 경우도 있지만, 서로 상응되어 유기적으로 작용되는 기능이 있을텐데 > done list와 신뢰도 api 때의 이슈를 생각하자   
    - 이때 나만의 기준을 가지고 사용을 해야하고, 조금이라도 헷갈리고 이해가 안되는 부분이 있다면 각각의 포지션 사람들과의 끊임없는 소통 필요
    - 아무래도 서버쪽에서 데이터를 넘겨줄때 내가 생각한 부분과 다를 수도 있고, 내가 모르는 부분도 있을테니 그 부분에 대해서는 내 스스로 더 공부도 하고 알아본다음에 질문을 해야하고, 이번 모플 작업에 있어서는 시니어 한분에게 먼저 확인을 해보고 내 질문의 타당성을 확인해본뒤 질문을 하게 되어 서버나 다른 포지션 사람들과 빠른 의사소통이 가능할 수 있었음.

- 쿠킹덤
  - 쿠키런 킹덤이라는 게임에서 보상해주는 아이템 리스트를 긁어와 어플리케이션 내에서 직접 보상을 등록할 수 있는 서비스
  - ios 1명, 서버 1명
  - 실제 게임을 하는 유저로써 해당 어플리케이션이 있으면 좋겠다는 생각을 하게 되어 시작하게 되었음 > 기획
  - 현재 서버에서 쿠폰 리스트가 넘어와서 해당 리스트를 불러와 화면에 뿌려주는 부분과 WKWebView를 통해 웹페이지를 불러오는 부분까지 진행
  - 구체적인 due가 정해지지 않은 상태에서 진행하고 있기때문에 속도가 더딘 부분이 있음.
  - 서버쪽에서 사정이 생겨 지금가지는 속도가 더디게 흘러갔지만, 앞으로는 서로 구체적인 계획을 만들어 올 여름 이내에 앱을 완성할 예정

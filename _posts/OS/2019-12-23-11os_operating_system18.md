---
layout: post
title: 가상메모리(Virtual Memory)와 요구페이지(Demand Paging)
category: OS
tags: [OS, operating system]
comments: true
---

> 개인공부 후 자료를 남기기 위한 목적임으로 내용 상에 오류가 있을 수 있습니다.    
경성대학교 양희재 교수님 수업 영상을 듣고 정리하였습니다.     

<hr>

## 가상메모리(Virtual Memory)

물리 메모리 크기 한계 극복하기 위해 생겨남

물리 메모리보다 큰 프로세스를 실행? e.g) 100MB 메인 메모리에서 200MB 크기의 프로세스 실행

#### 어떻게 해결할까?

프로세스 이미지를 모두 메모리에 올릴 필요는 없다. 즉, **현재 실행에 필요한 부분만 메모리에** 올린다.<br>
오류 처리 제외, 배열 일부 제외, 워드프로세스에서 정렬, 표 기능 제외 -> `동적 적재(dynamic loading)과 비슷한 개념`

즉, 일반적으로 프로세스를 메모리에 올린다고하면 code, data, stack을 한번에 다 올려야 한다고 생각하지만, 실제로 그럴필요가 없다.

좀 더 현실적으로 프로세스가 여러개가 있고 이를 메모리에 올리려고 한다면, 각 프로세스를 페이지별로 쪼개고(일정 크기로) 각각 필요한 페이지만을 메모리에 올린다. 크기가 큰 프로세스 전체는 메모리에 다 올릴 수가 없지만, 지금 이 순간에 필요한 애들만(쪼개져 있는 애들 중) 올리면 충분히 메모리에 올릴 수가 있게된다. 이렇게 프로세스를 자르되, 요구되는 페이지만 메모리에 올리는 것을 **요구페이지** 라고 한다.


## 요구 페이지(Demand Paging)

프로세스를 페이지 단위로 잘라서 메모리에 올리는데 요구되는 페이지만 메모리에 올리고 필요하지 않은 페이지들은 backing store(하드디스크)에 저장해주는 것 <br>
페이지가 요구되어지면 그때 그때 들고 올라온다 > `요구페이지`

- 프로세스 이미지는 backing store에 저장
- 프로세스는 페이지의 집합
- 지금 필요한 페이지만 메모리에 올린다(load) -> **요구되는(demand)페이지만 메모리에 올린다**


### 요구페이지를 만들기 위해서는 어떤 하드웨어가 필요할까?

1. **valid bit** 추가된 페이지 테이블
2. backing store(=swap device)


### 페이지 결함(Page fault) = 페이지 부재

접근하려는 페이지가 메모리에 없다(Invalid)

페이지 결함이 일어났다는 것은 cpu 어떤 주소를 냈는데, 그에 해당하는 페이지 엔트리 내용이 0으로 나타났다는 것<br>
이때 페이지 테이블에서 cpu로 전기신호(인터럽트)를 보내게 되고 이를 감지한 cpu는 os에게 routine을 통해 (page fault routine)을 실행하게 된다.

**Steps in handling a page fault**<br>
Backing store에서 해당 페이지를 가져온다.<br>
cpu가 어떤 주소를 냈고 해당 주소에 대해 invalid를 보게되면 page table에서 cpu에 interrupt를 걸어<br>
os루틴안에서 해당 페이지를 읽어서 메모리로 가져오고 가져온 프레임 번호를 테이블에 기록하고 해당 비트를 valid로 하면 원하는 페이지를 열 수 있다.


#### 용어: pure demand paging vs prepaging

**순수 요구페이징(pure demand paging)** : 진짜 필요한 애들만 가져오는 것<br>
프로그램이 처음 시작할 적에 지금 필요한게 아니면 아무것도 들고오지 않기 때문에 처음 시작할 때부터 page fault가 일어난다.

그래서 속도는 느리지만, 메모리가 절약된다.

**미리페이징(prepaging)** : 지금 필요하지 않아도 미리 몇페이지를 가져오는 것

속도는 빠르지만(page fault가 적게 일어남) 메모리 낭비가 있다.


#### 비교: swapping vs demand paging

- Swapping: 메모리와 backing store를 움직이는 단위가 프로세스 단위로 움직임
- Demand Paging: 갖고오는단뒤가 페이지 단위임


### 유효 접근 시간

cpu가 주소를 낼때 빠르게 읽히는게 있고, 느리게 읽히는 게 있는데 이때 평균적인 속도는 얼마정도일까를 유효접근시간이라고 한다.<br>
메모리의 어떤 영역은 빠르게 읽히고, 느리게 읽힐텐데 이에 대한 평균 시간(확률)


- Effective Access Time
  - probability of a page fault = page fault rate
  - T = (1-p)T + pT
  - 유효접근시간 = (1-page fault가 일어날 확률) * 메모리 읽는 데 걸리는 시간 + page fault가 일어나면 걸리는 시간

이 확률이 낮을 수록 좋은 건데 현실적으로는 어떨까?


### 지역성의 원리(Locality of reference): cpu가 참조하는 주소가 지역에 모아져있다

메모리 접근은 시간적, 공간적 지역성을 가진다. 실제 페이지 부재 확률은 매우 낮다.

- 시간적 지역성: cpu가 읽은곳을 나중에도 읽을 수가 있다. 코드에는 반복문이 많고, 한번 읽은 애를 또 읽을 확률이 높다.
- 공간적지역성: 지금 1000번지를 읽으면 나중에도 1000번지에 인접한 구역을 읽는다. 주소만 들고오는게 아니라 블락 단위로 가져온다.

**다른방법**

HDD는 접근 시간이 너무 길다 > swap device로 부적합<br>
SSD 또는 느린 저가 DRAM 사용한다!

---
layout: post
title: 이중모드, 하드웨어 보호
category: OS
tags: [OS, operating system]
comments: true
---

> 개인공부 후 자료를 남기기 위한 목적임으로 내용 상에 오류가 있을 수 있습니다.    
경성대학교 양희재 교수님 수업 영상을 듣고 정리하였습니다.     

<hr>

## 이중모드(Dual Mode)

한 컴퓨터를 여러 사람이 동시에 사용한다. (수강신청할 적에 서버 컴퓨터는 하나지만 여러명이 사용하겟지, 한 사람이 여러개의 프로그램을 동시에 사용하는 것) 한 사람이 고의/실수로 잘못하면 그 영향이 전체에 미칠 수 있는 (전체가 다운될 수 있는) 환경이라면 ..

다운 시키는 명령어 = stop, reset, halt = cpu가 중지/
어떤 사용자가 자기 프로그램을 깔고 하드디스크에 stop이라는 명령을 넣어뒀다고 하자, 그 프로그램이 메인 메모리로 올라가서 stop명령이 cpu가 들고와서 실행하면 cpu가 정지된다. 정지된 cpu가 다시 동작하는 방법은 컴퓨터를 껏다 키는 방법 뿐이다. 서버컴퓨터일수록 그 시간은 더 오래 걸리겠지. 혼자 사용하는거면 그나마 났지만, 여러명이 하는 컴퓨터일수록 치명적이다.

그래서 사용자 프로그램(일반 유저)들은 이런 명령어를 사용하면 안되겟지. 오로지 관리자만 내릴 수 있어야겠지. 그래서 이중모드를 만들었어.

이중모드는 cpu가 동작하는 모드를 2가지를 두겠다는것
- 사용자(user) 모드: 일반 사용자가 사용하는 모드
- 관리자(supervisor,시스템(system), 모니터(감시자, monitor), 특권(priviliged mode)) 모드: 컴퓨터에서 관리자는 os

cpu가 메모리에 있는 명령을 읽어와서 실행하는데, os에 있는 명령을 실행할 적에는 cpu가 관리자 모드에서 동작하도록 하고 일반 유저 영역의 메모리를 가져와 실행하면 사용자모드에 있도록 한다.

-> 특권명령(priviliged instruction): 유저 모드와 관리자 모드가 있는데, 관리자 모드에서만 내릴 수 있는 명령. stop, halt, reset, set_timer(서버 컴퓨터에 일반 유저가 컴퓨터 시간을 자기 멋대로 바꾸면 안되잖아. 다른 사람에게도 시간이 엉망이 되니까), set_HW(하드웨어의 값을 바꾸는 것)

이런 명령은 일반 사용자가 아닌 반드시 os(운영체제, 관리자)만이 내릴 수 있도록 한다.

### 이중모드는 어떤식으로 만드는가?

cpu안에는 레지스터, alu, cu도 있는데.
레지스터: 비트들의 모음. 32bit라고 하면 비트가 32개 들어있음.
이 비트들에는 어떤 프로세서(cpu)의 상태를 알려주는 비트를 들 수 있음
- 캐리(carry)
- negative: 연산의 결과가 음수가 나왔을때
- zero: 앞의 연산이 0이 나올때
- overflow: 앞의 연산이 그 연산 결과가 자리 범위를 넘었을때
이런것을 fleg:깃발, 사건이 일어나면 깃발을 들고 사라지면 내리고 같이 상태를 나타내는 것을 플래그라고 함. 1이면 발생한것이고 0이면 발생안한것이고..

이중모드에서 갑자기 플래그?

플래그에 하나를 더 추가하는 것! os에서는 비트를 하나 더 추가하는 것. 그 비트 이름 : monitor, system 등
이중모드를 나타내는 비트를 하나 더 추가하는 것! 만약 얘가 1이면 시스템 모드가 되는것이고 0이면 유저 모드가 되는 것!
레지스터 안에 있는 1개의 비트를 모니터 비트로 할당해서 이중모드를 나타냄

처음 파워를 키면 부팅이 일어나고 os가 메인메모리로 올라가고 올라가는 도중에는 모두 모니터 비트가 다 1(시스템모드) 즉, os가 동작할 적에는 시스템모드에서 동작한다(모든 명령을 다 내릴 수 있다) 그래서 os 부팅이 끝나면 메모리에 사용자 프로그램을 올림
cpu는 그 프로그램을 실행하겠지. 근데 os가 돌적에는 시스템 모드지만 이제 os에서 사용자 프로그램으로 갈 적에는 os의 비트를 0으로 만들어준다. 즉 유저 모드가 되도록 한다. 그래서 사용자 프로그램이 동작할 때는 유저모드에서 동작하는 것이다.

즉 os모드: 관리자 모드
os가 새로운 프로그램을 실행하면 그 프로그램가 올라오고 (이는 곧 os가 해당 프로그램을 하드디스크에서 메모리로 올리겠지) 그럼 그 os가 프로그램을 메모리에 올리고나면은 cpu에서는 프로그램이 실행되기 직전에 해당 비트는 1에서 0으로 만들어준다. 그래서 사용자프로긂이 사용될때는 사용자모드에서 동작이 된다. 그래서 해당 사용자 프ㅡ로그램에서는 stop과 같은 특권 명령어는 사용하지를 못한다.

그러다가 내가 사용자프로그램에서 햇던 행위는 하드디스크에 저장하고싶다면?
프로그램 자체가 하드디스크에 저장을 해도되지만 문제가 많다. 이는 곧 유저 프로그램이 하드디스크에 접근이 가능하다는 것인데, 이는 하드디스크의 남의 파일도 접근이 가능하다는 뜻이다. 즉 서버컴퓨터에는 여러 사용자들의 파일들이 저장되어있을텐데 이는 남들이 접근이 가능하면 안되잖아. 즉 일반 사용자프로그램이 하드디스크를 직접 접근하는것은 보안에 심각한 문제를 끼친다.

즉, 여기에 접근하는 것은 해당 프로그램이 os에 부탁을 해야한다. 즉, 하드디스크같은 자원을 접근할때는 os에 부탁을 해야한다. 즉 이 부탁은 swi! 를 이용해서 부탁. cpu는 지금 하는 일을 중지하고 isr로 접근! 그래서 os안에 있는 루틴에 접근해서 하드디스크에 저장할 수 있도록 한다.

그때 어찌됐든 os로부터 인터럽트를 걸어서 cpu의 모드가 1로 변경되면 이제 os에서는 무슨 명령이든 내릴 수가 있게되고 이때 유저 프로그램에서는 그 어떤 명령들도 내릴 수가 없게된다. 이제 저장을 하고나면 다시 유저영역으로 돌아오고 모니터비트를 다시 0으로 바꿔준다.

대부분의 모든 cpu는 이중모드를 지원한다. (모니터를 나타내는 비트가 따로있음)
그래서 절대 일반유저가 특별한 명령을 내리지 못한다. 만약 내리려면 어떻게 될까?
cpu가 그 명령을 읽어왔는데 모니터비트를 확인하고 0인데 stop? cpu는 이 명령이 잘못된 명령이라고 생각해서 내부적으로 인터럽트가 발생했다고 생각한다. 그래서 os의 isr(해당 프로그램이 잘못된 명령을 내렸을때 처리하는 루틴)! 그 프로그램을 강제로 종료시킴 -> 바로 메모리에서 삭제시켜버림!

이중모드는 이런면에서 보호와 관련이 있다.(protection)
컴퓨터에서 보호받아야하는 3가지

- 입출력장치 보호(IO, Input/Output device protection)
일반사용자가 하드웨어를 자기멋대로 사용할 수 있도록 하면 안됨.
예로 들어서 서버컴퓨터는 동시에 여러사람이 사용하는데 거기에 프린트가 달려있다고 하자. 서버컴퓨터를 경우해서 프린트를 사용하는데 다른사용자가 그 프린트에 대해 리셋 혹은 자기도 찍겠다고 신호를 보낸다면 프린트의 한줄에는 다른 사람꺼도 찍히겠지.
프린트 혼선, 강제 리셋, 혹은 프린트 말고도 서버컴퓨터에는 대용량 하드디스크도 달려있겠는데, 그 하드디스크에 여러사람들의 파일들이 들어있을텐데 자신의 중요정보를 하드디스크에 저장했는데, 다른애가 그 하드디스크를 접근해 맘대로 보려면 안되잖아 -> priviliged instruction violation
그러니까 프린트, 하드디스크 등은 보호를 받아야 한다. 아무나 볼 수 없도록

보호하려면, 이 접근을 못하도록 하려면 입출력장치를 제어해야함
입출력장치와 관련이 있는 명령어들은 아래와 같다.
-> in(키보드나 마우스 같은 입출력 장치로부터 정보를 받아들이는 것), out(출력장치에 명령을 내리는것(출력을 내보내라고), 프린트, 디스크, 스피커, 램 등)
-> 이런 명령어들을 priviliged instruction
이런명령들은 os만 내릴 수 있도록!

근데 정말 이 프로그램이 프린트를 하고싶어. 그렇다면 해당 프로그램이 os에게 부탁을 한다. 그러면 os는 해당 부탁이 올바른지를 판단해 올바르면 -> 해당 프로그램이 swi/int라는 명령어를 내리면 cpu는 마치 인터럽트가 걸려왔다고 생각해서 cpu가 하는 일을 중지하고 os의 isr을 통해 프린트를 가동시켜줌(os가) 올바르지 않으면 거부!

입출력 관련 명령어는 무조건 특권명령어!

- 메모리보호 (Memory protection)
유저1프로그램이 돌면서 유저 2,3 메모리 영역을 읽으려고 하는것. 혹은 os안의 값을 바꾸려고 한다면?
그게 해킹인데, 보호 받아야겠지.

cpu에서 메모리로 address bus(몇번지를 읽겠다.)가 가면 data bus(몇번지에 해당하는 데이터)를 통해 cpu로 오게 된다. 일반 유저프로그램이 os나 다른영역에 가지않게하려면 address bus를 잘라버림
잘라버리면 근데 자기 영역에도 못들어가겟지. 해결책이 아님
그러면 다른 방법은 address bus에 문지기를 세워둠
어떤 주소를 낼 적에 그 주소가 해당 영역에 해당되는 주소가 맞다면 문지기가 통과시켜주고 벗어나면 문지기가 거절을 내버림.

이 문지기(MMU: Memory management unit)는 실제로 레지스터를 둔다. base, limit 이런식으로 base에서 limit 사이에 들어오면 통과, 벗어나면 cpu로 다시 인터럽트 신호가 가도록한다. 인터럽트 신호를 보내주면 cpu는 하던일을 중지하고 os의 isr로 점프하고 해당 isr는 잘못된 번지를 읽으려고 시도하면 그 프로그램을 강제로 종료!
segment violation : 영역에 대한 침범 > 해당 에러를 발생시키며 강제 종료시킴!

이 mmu의 base, limit 값 설정은 os가 해준다. 이 값을 바꾸는 것은 특권명령으로 해서 올려둬야함

- CPU 보호 (CPU protection)
cpu도 어떤 침범 대상이 되겠지. 유저 1가 cpu 시간을 독접하게 되어버리면 ?
timer를 둔다. timer는 일정주기로 신호를 내보내는데, 즉 timer가 일정 주기로 cpu에 인터럽트를 걸도록 회로를 설계. 얼마 지나면 인터럽트 걸고.. 그러면 cpu는 os의 isr로 점프하고 해당 isr에는 해당 cpu가 골고루 돌아가고 있는지를 체크하고, 오랜 시간이 지났는데도 한 유저에게만 묶여있다면 isr이 cpu로 하여금 강제로 해당 프로그램이 아닌 다음 프로그램으로 넘어가도록 조정해줌

어느 한 유저프로그램에만 묶여있지않도록 한다. 그래서 timer를 두면 일정시간 지나면 인터럽트 걸리고 해당 isr로 점프하게 되어 해당 루틴이 너무 묶여있는 것 같다면 다음 프로그램으로 넘어가도록 한다. 

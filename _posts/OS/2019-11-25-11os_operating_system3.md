---
layout: post
title: 고등운영체제, 인터럽트 기반 운영체제
category: OS
tags: [OS, operating system]
comments: true
---

> 개인공부 후 자료를 남기기 위한 목적임으로 내용 상에 오류가 있을 수 있습니다.      

<hr>

## 고등운영체제

1. 다중 프로세서 시스템(Multiprocessor system): 메모리는 하나인데 cpu가 여러개인 시스템
  - 병합 시스템(Parrallel system): cpu가 여러개, 병렬로 있다.
  - 강결합 시스템(tightly-coupleds system): 강하게 결합, 하나의 메모리에 cpu가 여러개 강하게 결합되어있다.
  - 3가지 장점(performance, cost, reliability): cpu는 계산하는 역할인데, 이 일꾼이 여러개 있으면 더 많은 계산이 가능하겠지(performance)-성능향상,비용면에서 컴퓨터는 빠를 수록 좋은데 하나의 강한 cpu보다 싸지만 여러개를 cpu를 두는게 비용적에서 더 효율적이다(cost)-비용절감, 혹시 하나가 고장나더라도 다른 애들을 사용할 수 있으니까(reliability)-신뢰도
  - 다중 프로세서 운영체제(multiprocessor OS): 당연히 cpu가 하나일때의 os와 cpu가 여러개일때의 os는 다를텐데, cpu가 하나일때는 생각해야할게 단순한데 여러개일때는 스케줄링이 다르잖아. 그래서 당연히 싱글 cpu일때와 multiple일때의 os는 다를수밖에 없고, cpu가 여러개일때는 multiprocessor OS라고 한다.

2. 분산시스템(Distributed system): cpu-memory(하나의 컴퓨터)로 구성된 여러개의 컴퓨터를 근거리 통신망(LAN)으로 연결. cpu도 여러개, 메모리도 여러개로 이루어진 시스템
그리고 하나의 LAN에 들어있는 cpu와 메모리.
  - 다중 컴퓨터 시스템(multi-computer system): 하나 하나가 컴퓨터
  - 소결합 시스템(loosely-coupled system): 메인 메모리를 공유하지 않으니까, 그리고 하나의 LAN상에서 느슨하게 결합되어 있음
  - 분산 운영체제(Distibuted OS): 한 컴퓨터의 os는 다른 애들과 아무연관없는 일을 하는게 아니라 하나의 일을 서로 나누어서 일을 하게 되기 때문에 서로간의 메시지를 주고받으며 공통의 목료를 이룬다.

1과 2의 시스템은 각각 목적이 같다
- 강한 컴퓨터(성능이 좋다는건 빨리 계산한다는것)
- 비용절감
- 신뢰성(하나가 죽어도 다른일을 할 수 있음)

즉, 구현방식이 달라고 하고자하는 목표는 같은것
근데 3은 다름

3. 실시간 시스템(Real-time system): 어떤 계산을 하는데, 그 계산이 어떤 시간내에 반드시 끝내야하는 시스템을 실시간 시스템이라 한다.
스마트폰에서 컴파일(하이레벨 랭귀지를 기계어로 변환하는것)을 한다고 할때, 그 변환하는 시간이 얼마나 걸리나? 얼마나 빨리 변한되는게 좋은가? 컴파일은 단순히 빨리되면 좋다는거에서 넘어가 컴파일이 반드시 몇ms안에 끝나야한다. 제한을 주는것  
  - 시간제약: Deadline :이 선을 넘어가면 죽는것. 이 시간을 정해서 컴파일을 해서 그 시간내에 반드시 끝나야하는 시스템. 그것을 지나가면 실패한 시스템이라 한다. (ex.네이게이션..) 타이트한 시간 제약을 주는 것
  - 공장 자동화(FA), 군사, 항공, 우주: 어디에 사용되는가?
  - 실시간 운영체제(Real-time OS = RTOS): 3초내에 끝내야한다고 하면 못 끝날것같으면 나머지 다른애들을 희생시키고(바쁘지 않으니까) 다른애한테 갈 시간을 좀 더 투자하는것.


## 인터럽트 기반 시스템(Interrupt-Based System)

가로채기, 현재 운영체제는 전부다 인터럽트 기반 시스템이다!

컴퓨터는 프로세서와 메인메모리, 보조기억장치(하드디스크 혹은 플래시 메모리)가 있다. 그리고 이 하드디스크 안에는 os가 들어있다. 이 외에도 하드디스크에는 여러 실행파일들이 들어있다(인터넷 익스플로어, 게임, 아래한글, 워드)

처음 파워를 키면 메인 메모리는 다 비워져있고 cpu는 롬에 있는 코드가 먼저 동작을 한다. 롬안에는 부트로드가 하드디스크를 뒤져 os를 메인 메모리의 램으로 들고온다. 이를 부팅이라고 한다. 이 부팅이 끝나고 나면 이 컴퓨터는 os가 딱 제어를 하고 있는 상태가 된다. 윈도우 바탕화면 등 마우스 커서가 보이겠지. 그럼 이 운영체제는 램에 상주하게 된다(레지던트)

이렇게 부팅이 끝나면?
바탕화면이 보이고 마우스가 깜빡이는걸 볼 수 있다. 마우스를 움직이지 않은 상태에서
os는 일단 아무것도 안하고 가만히 있다. cpu도 아무것도 안하고 있다.
그런데 마우스를 움직으면 무슨일이 일어날까?
이 마우스에서 전기신호가 발생해서 그 전기신호가 cpu에 보내지게 된다. 이 마우스가 실질적으로 cpu에 연결되어 있는 것은 아니지만, 논리적으로 이 마우스가 인터럽트 선이라고 하는곳으로 전기신호를 보내게 된다. 이 cpu는 어디로 점프를 하게 된다. 인터럽트라고 하는것은 지금 하는일을 중지하고 점프를 하는것인데, cpu는 마우스가 전기신호를 보낸것을 파악하고 지금 하던일을 중지하고 os안에 보면 마우스가 전기신호를 보내면 어떤일을 하라는 명령이 있을것을 확인하고 (Interrupt service rootine: 인터럽트가 일어나면 이런 서비스를 해주는 코드)

즉, 우리가 바탕화면이 나타나 마우스를 움직이면 인터럽트가 발생한것이고 그 인터럽트 신호가 cpu에 보내지게 되면 cpu는 지금 하던일을 중지하고 os로 넘어가 os안에 들어가있는 마우스 Interrupt service rootine으로 점프한다. 그러면 여기에는 어떤 코드가 들어있을까?
-> 마우스가 움직이는대로 모니터의 커서를 옮기는 루틴이 들어있다. 즉 마우스를 움직이면 마우스 커서가 동시에 움직이잖아. 이는 인터럽트가 걸려서 이 서비스 루틴에서 그렇게 하도록 되어있는 것을 의미한다.

이 마우스커서가 hwp에 갔다고 하자. 그럼 또 더블클릭을 하겟지. 더블클릭을 하면 인터럽트에 걸릴것이고 이는 os에 들어가 해당 코드가 무엇인지를 확인한다. 더블클릭의 루틴을 확인해서(그 더블클릭의 지점 x,y좌표에 해당하는 곳이 hwp구나 라는것을 확인하고) 이 마우스 인터럽트 서비스 루틴이 하드디스크를 뒤져서 하드디스크 안의 hwp를 뒤져서 확인한뒤 메인메모리로 가지고 온다. 그리고 그 메인메모리에 hwp프로그램이 올라가고 그럼 바탕화면이 달라지고 모니터에는 아래한글 초기화면이 나타나게 된다.

키보드의 경우도 마찬가지다. 키보드의 어떤 키라도 누르면 전기신호가 가서 cpu는 하던일을 멈추고 os안의 키보드의 인터럽트 서비스 루틴으로 점프하게 된다. 즉, os는 하나의 프로그램이고 그 안에는 여러가지 코드가 있는데 그 코드는 인터럽트가 걸려오면 작동을 한다.

이렇게 해당 동작이 멈추게 되면 이제 cpu는 다시 대기하고 있는다.

지금까지는 하드웨어 인터럽트에 의해 실행되는 것

하드웨어 말고도 소프트웨어 인터럽트도 있다. > swi

hwp 프로그램이 메인메모리로 올라오면 실행되겠지. 그러면 hwp 실행되다가 하드디스크의 어떤 내용을 읽어오고 싶다고 하자. 그러면 이 읽어오는 명령은 하드디스크를 읽어오는 루틴은 os안에 들어있다. 하드디스크 안의 내용은 os가 하드디스크를 읽는 코드가(이것도 인터럽트 서비스임) 읽어옴. 그래서 hwp가 하드디스크의 내용을 읽어오고 싶다면, swi를 걸고 하드웨어가 os에 인터럽트를 걸듯이 hwp위의 swi가 os에 점프를 하게되고 os안에 있던 코드가 하드디스크에 가서 하드디스크 안에 있던 파일을 읽어와 메인 메모리에 가져오고 다 읽고나면 다시 hwp 프로그램으로 돌아온다.

하드디스크를 읽어들이는 코드는 즉, os안에 들어있다.(중복을 피하기 위해서) 일반 프로그램 안에는 들어있지 않다.

즉, os안에 들어잇는 인터럽트 서비스 루틴을 실행시키려먼 하드웨어, 소프트웨어 인터럽트에 의해서도 실행이 된다.

이 os안에는 많은 코드들이 들어있는데, 이 os안의 코드는 인터럽트를 통해서 실행이 된다. 그래서 현대 운영체제가 인터럽트 운영체제라는것이 그 의미이다.

운영체제는 평소에는 그저 대기상태임! 평소에는 하는일이 없고 인터럽트가 걸려오면 실행이 되고 이 인터럽트는 마우스, 키보드 등이 움직이면 하드웨어 인터럽트가 발생하고 os 안의 인터럽트 서비스 루틴이 실행된다.

그리고 hwp같은 사용자 프로그램도 swi명령을 실행하면 인터럽특 걸려서 os 코드가 실행되게 된다.

말고도 내부 인터럽트에 의해서도 실행이 된다. 이 대표적인 예는 컴퓨터 프로그램을 짰는데, 코드내 연산에서 값이 없는 코드가 나오게 되면 그 밑의 코드로는 진행이 안될것이다. 이런 경우 컴퓨터의 입장에선 cpu에서는 프로그램을 가져와서 실행을 했는데 실행할 수 없는 경우(저장이 안되니까) cpu는 내부적으로 인터럽트가 발생한것으로 인식하여 os안에는 divide by zero(0으로 나누면 이 코드를 실행하라)라는 코드가 있다. -> 프로그램을 종료시키는 인터럽트 서비스 루틴이 있어서 이를 실행시킨다.

우리가 사용하는 모든 운영체제는 인터럽트 기반의 운영체제를 사용하고 있다. 그 인터럽트는 하드웨어, 소프트웨어, 내부 인터럽트가 있을 수 있다. 이런 경우에 일어나는 것을 인터럽트 기반 운영체제라고 한다.

그래서 이 인터럽트 운영체제라는 것은

컴퓨터에는 cpu와 메모리가 있는데 이 메모리 안에는 os가 있고 이 os안에는 여러개의 루틴들이 들어있다. 이 os안의 코드는 보통때는 실행이 안되다가
유저 프로그램이 실행되다가(메모, 게임, 데이터베이스 등등) 하드디스크나 프린트를 이용하고 싶을때, 이 하드디스크나 프린트를 동작시키는 것은 os잖아. 그래서 이 시점에서 swi를 걸면 인터럽크 서비스 루틴으로 점프를 해서 그 os에서 프린트를 실행시키고 프린트 가동이 끝나면 다시 사용자 프로그램을 실행시키고 다시 하드디스크를 읽고싶다면 또 swi를 걸고 서비스 루틴으로 점프해서 os에서 이를 다시 실행시키고 그게 끝나면 다시 프로그램으로 내려오고 이를 반복한다.

즉, 하나의 프로그램을 동작하기 위해서는 유저 영역의 메모리가 동작하다가 os를 갔다가 이를 반복한다. 이런 식으로 os안의 코드가 실행된다.

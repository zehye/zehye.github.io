---
layout: post
title: 연속 메모리 할당(Contiguous Memory Allocation)
category: OS
tags: [OS, operating system]
comments: true
---

> 개인공부 후 자료를 남기기 위한 목적임으로 내용 상에 오류가 있을 수 있습니다.    
경성대학교 양희재 교수님 수업 영상을 듣고 정리하였습니다.     

<hr>

## 다중 프로그래밍 환경에서...

- 부팅 직후 메모리 상태: O/S + big single hole
- 프로세스 생성 & 종료 반복 -> scattered holes(쪼개져있는 holes)

- `메모리의 단편화(Memory fragmentation)`:hole들이 떨어져있음
  - Hole들이 불연속하게 흩어져 있기 때문에 프로세스 적재 불가
  - `외부 단편화(extend fragmentation)`발생: 홀들이 연속되어져있지 않고 떨어져 있음<br>
  -> 흩어져 있는 메모리를 합쳐서 사용하면 새 프로세스를 올릴 수 있는데 연속되어 있지 않아 올릴 수 없는 불편함 존재(낭비)
  - 외부 단편화를 최소화 하려면?

### 외부 단편화를 최소화 하려면? = 연속 메모리 할당

- First-fit(최초 적합): 메모리를 순차적으로 찾아 제일먼저 발견되는 곳에 넣는 것
- Best-fit(최적 적합): 제일 사이즈가 밀접한 곳에 넣는 것
- Worst-fit(최악 적합): 크기가 제일 안맞는 곳에 넣는 것

예) hole: 100/500/600/300/200 KB | 프로세스: 212 417 112 426 KB

- First-fit(최초 적합): 426은 넣을곳이 없음(외부 단편화)
- Best-fit(최적 적합): 다 넣을 수 있음(메모리를 제일 잘 사용한 방법)
- Worst-fit(최악 적합): 여전히 426은 들어가지 못함


**할당 방식 성능 비교: 속도 및 메모리 이용률**

- 속도면에서는 first-fit이 좋다 -> 제일 먼저 나오는곳에 넣으면 되니까
- 이용률: `first-fit, best-fit` -> 메모리가 얼마나 잘 이용되는가를 비교하자면 둘은 거의 비슷하게 나온다.

그러나 best-fit을 사용했음에도 불구하고 `외부 단편화로 인한 메모리 낭비는 존재`: 메모리의 1/3수준은 여전히 사용불가 수준
- `Compaction`: 메모리에 흩어진 hole들을 하나로 모은다. 최적 알고리즘 없음, 고부담(홀을 옮길지, 프로세스를 옮길지, 그 크기에 따라 굉장히 복잡함)
- 다른 방법은? Paging


### 페이징(Paging)

프로세스를 일정크기(=페이지)로 잘라서 메모리에 넣는다. (메모리를 일정한 단위로 잘라서 홀 안에 넣는다.)
- 프로세스는 페이지(page)의 집합
- 메모리는 프레임(frame)의 집합
- page의 사이즈와 frame의 사이즈는 똑같다. (해당 page는 각각의 frame에 들어가야 하니까)

**페이지를 프레임에 할당한다**

- MMU내의 Relocation register값을 바꿈으로써 `cpu는 프로세스가 연속된 메모리 공간에 위치한다고 생각하게 한다.`
- `MMU는 페이지테이블(page table)`이 된다.

<center>
<figure>
<img src="/assets/post-img/OS/39.jpeg" alt="" width="30%">
</figure>
</center>


일반적으로 프로세스를 잘라서 넣으면 프로그램은 실행이 되지 않는다. 이를 실행하기 위해서는 `cpu를 속여야 한다.`

cpu에 Relocation register를 여러개를 둠으로써 cpu는 연속으로 주소를 보냈다고 생각하지만, mmu를 거칠적에는 새로 연산을 해주게된다(다른 값을 내준다)<br>
cpu는 여전히 메모리에 연속적으로 들어갔다고 생각하지만 실제 메모리에는 막 들어가져있다(다른 곳에 매핑 될 수 있도록 해준다)

사실은 메모리 전체를 처음부터 일정크기로 나눈다. 그리고 프로세스를 올릴 적에도 그냥 연속해서 올리는게 아니라 여러개의 페이지로 쪼개 올린다. 흩어져 잇음에도 불구하고 cpu를 속여 mmu값을 적절하게 넣어 연속적이게 보이도록 해준다.
`logical address는 연속, physical address는 불연속`

이를 통해 메모리의 외부단편화 문제를 해결할 수 있게 된다.


### 페이징에서의 주소 변환(Address Translation)

- 논리주소(Logical address): cpu가 내는 주소
  - cpu가 내는 주소는 2진수로 표현(전체 m비트)
  - 하위 n비트는 오프셋(offset)또는 변위(displacement, d)
  - 상위 m-n비트는 페이지 번호(p)

이 전체중에 n을 몇비트로 할것인가는 페이지 사이즈를 얼마로 하는가에 따라 달라진다.<br>
한 페이지 사이즈가 16byte라고 한다면 16byte단위로 자른다는것. 그렇다면 하위 n비트에 주어지는것은 4(2의 4승=16byte)비트이다.

<center>
<figure>
<img src="/assets/post-img/OS/40.jpeg" alt="" width="30%">
</figure>
</center>

- 주소변환: 논리주소 -> 물리주소(Physical address)
  - 페이지번호(p)는 페이지 테이블 인덱스 값(p=m-n)
  - p에 해당되는 테이블 내용이 프레임 번호(f)
  - 변위(d)는 변하지 않음

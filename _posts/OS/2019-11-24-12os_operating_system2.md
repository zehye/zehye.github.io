---
layout: post
title: 운영체제 역사
category: OS
tags: [OS, operating system]
comments: true
---

> 개인공부 후 자료를 남기기 위한 목적임으로 내용 상에 오류가 있을 수 있습니다.      

<hr>

컴퓨터에 os가 특별한 일을 안한다. 우리가 보기에는, 그러나 os가 없다면 그 컴퓨터는 아무것도 할 수 있는 게 없다. 그래서 os가 하는 일을 봤을때 자원을 나눠주는 것.

그리고 os의 역할은 크게 두가지
- 성능개선
- 사용자 편리성 제공

## 역사


### No operating System

- 컴퓨터는 언제 만들어졌나?
  - 2차 대전 중에.. 1040년대 말
  - 컴퓨터의 발전과 하드웨어 발전과 함께 운영체제 기술도 발전
- 제일 처음 보는 컴퓨터는?
  - 옛날 컴퓨터는 너무 커서 책상위에 둘수도 없었고 아예 건물 안에 들어가 잇었음
  - 그 건물에서 제일 큰 비중을 차지하는 것은 입력장치(카드리더)
  - 이 카드리더에 여러가지 카드의 내용을 읽어 처리함
  - 그 내용을 프린트에 찍음
  - 이 처리기 안에는 메모리도 있고
- 이떄 컴퓨터는 일반인들은 사용 못했고 오퍼레이터가 따로 있었음
- 프로그래머가 종이에 연필로 프로그램을 적어주면
- 전산실에 넘기면 전산실에는 연필로 작성된 코드들을
- 카드에 구멍을 뚫어서 그 구멍을 통해 어디라는 것을 파악했음
- 그럼 이 내용들이 메모리에 적재되고(메모리가 프로세스에 올라가고)
- 메모리에 올라가게 되면 카드리더에 있던 파일은 삭제되고
- 이 메모리를 읽기 위한 컴파일러가 카드리더에 올라가 처리기로 옮겨지면서
- 처리기에는 메모리와 컴파일러가 올라가 있게 된다.
- 이 컴파일러는 이제 이 메모리를 번역하기 위해 기계어가 나오고
- 이 처리기는 이 기계어를 실행하고
- (이때는 모니터가 없으니 그 결과는 프린터에 찍힘)

그래서 처음에는 No operating system이었음

그러다가 이제 기술이 발전하게 되고 이제 컴퓨터 스스로 할 수 있도록 함

### Batch processing System

꾸러미, 묶어서 프로세스를 처리를 한다 (일괄처리)
어떤 일련의 일들(카드를 넣고 메모리에 적재하고 컴파일을 넣어 번역하고 컴파일 후 (라이브러리 링크하고) 그리고 메모리 적재한 데에 로딩을 해야하고 이 일련의 과정들을 오퍼레이터가 손으로 했다면 ,, 이 연속되는 일들을 이 메모리에 프로그램들을 넣어 컴파일을 하고 링크를 하고 로드하도록 하여 즉 이 일들을 하는 프로그램들을 메모리에 넣는 것을 일괄처리 시스템이라고 한다.

이 메모리 안에 들어있는 작은 프로그램을 레지던트 모니터라고 불렀다.

이 레지던터는 상주한다는 의미로 얘가 메모리에 상주해서 일괄적인 일들을 한다고 해서 batch라는 단어를 붙였다. 이게 최초의 운영체제라고 본다.

그 후에 기술이 발전되어 메인 메모리 외에도 하드디스크도 만들어지고 이 하드디스크는 기억용량이 크고 속도도 빠름. 그리고 이때의 메인메모리는 반도체 메모리가 아닌 진공관 메모리여서 이후 트랜지스터 등등이 생기면서 메모리가 굉장히 커지고, 프로세스 속도도 빨라짐

하드웨어 기술이 발전되며 os에도 변화가 컸고, 그 변화중에서도 멀티프로그래밍 !

### Multi programming

옛날에는 컴퓨터가 정말 비쌌고, 미국에도 많아야 5개가 안됐음(우리나라에는 없었고)
그래서 사람들이 생각해보면 batch도 좋지만 안좋은 부분이 있었음

우리가 기본적으로는 메모리에는 os가 있었고 유저 프로그램이 있었다. 즉, 메모리에는 크게 두가지 프로그램이 올라가있음. 이 유저프로그램에는 컴파일러가 될수도 있꼬 링크, 게임 등이 될 수도 있었는데 하나만 올라갈 수 있었음.

근데 하나만 올라가니까 하나의 프로그램을 보면 처음에는 cpu(프로세스)를 사용하는데 이는 계산하는것.. 얘만 사용하는게 아니라 io(입출력 장치)도 사용한다.

즉, 우리가 어떤 연산을 할때에는 cpu를 사용하고 이제 print를 해서 화면에 보이는것은 입출력장치 io를 사용한다. 이 입출력 장치가 사용될때는 cpu는 사용하지 못한다.

즉 시간경과에 따라서 cpu->io->cpu->io 이렇게 도는 것을 볼 수 있다.

유저 프로그램이 하나 있으면 처음에는 cpu가 동작하고 io가 실행할때에는 cpu가 할일이 없다. io가 마칠때까지.. 그래서 이때 cpu가 아무일도 안하고 놀게 되는데 이를 idle이라고 한다. idle은 아무일도 안하고 빙빙 돌고있다는 뜻

컴퓨터가 굉장히 비싼 자원인데, 이렇게 cpu가 놀고있도록 하면 안되니까 cpu는 빠른데 io는 느리니까.. 그 오랜 시간동안 아무것도 안하고 놀고있음.

디스크에서 아무리 빠르다 하더라도 여전히 느린데(cpu에 비하면) 그럼 디스크는 일하고 있어도 cpu는 놀고있으니 이를 해결할 방법은 메모리에 여러개의 프로그램을 돌리자!

이제 메모리에 유저 프로그램을 여러개를 두자 -> 이렇게 하면 이제
cpu가 돌게 되는데, 얘가 카드리더를 읽든지, 프린트를 뭘 찍을 사이에 cpu가 idle하지 않고 다른 프로그램(다른 유저 프로그램)으로 내려가게 된다.

그래서 원래 진행하고 있던 프로그램에서 io를 진행하고 있다고 하더라도 cpu는 계속해서 다른 프로그램으로 옮겨감으로써 일을 계속 하게될 수 있게된다. cpu는 되게 비싼 자원이기 때문에 이런식을 통해 메모리의 작업/프로그램을 수행하도록 한다.
어느 순간에도 cpu가 idle하지 않도록!

그래서 idle 타임을 대폭 줄이도록 한다. 그래서 cpu의 사용률이 굉장히 올라갈 수 있다. 그래서 메인 메모리에 여러개의 프로그램을 올리는 것을 다중 프로그래밍 시스템이라고 한다. 프로그램이 여러개.

단순하게 메모리에 프로그램을 여러개 올리는것만으로 끝나는게 아니라,
- cpu스케줄링: 메인 메모리에 프로그램이 여러개 있으면 어떤 순서대로?
  - 성능을 향상 시켜야 하니까, 성능이 더 좋은 방식으로!
- 메모리 관리: 이제는 메모리의 유저프로그램들이 많아졌으니까, 유저 프로그램들을 각각 어디에 배치하는것이 좋을까?
  - 프로그램이 종료된다면 이 새로운 프로그램을 넣으려고 하면 비어있는 곳? 아니면 그 다음?
우리는 cpu, memory 관리 더 나아가
- 보호: 다른 프로그램 영역까지 침범할 수 있으니 이를 막아햐 하잖아.

이제 60년대 후반 70년대로 오면서 모니터, 키보드가 생겨났다.
그래서 interactive가 가능해짐 (컴퓨터와의 대화가 가능)

옛날에는 컴퓨터 한대를 한사람이 쓰지 못했는데..
그래서 하나의 컴퓨터에 단말기를 연결해 각각의 컴퓨터와 키보드가 연결되어 있었음
근데 이때의 컴퓨터 모양은 지금과 비슷해보이지만 다른 건, 지금은 본체가 있어서 그 본체에 cpu와 메모리가 있고 그렇지만 과거에는 그냥 단순히 모니터와 키보드로만 이루어진 입출력 장치에 불과했다.

그래서 옛날에는 하나의 컴퓨터에 수많은 단말기를 달아서 사용!

이 컴퓨터를 여러명이 사용하려다 보니, 특히 멀티프로그래밍으로 사용하려다보니 문제가 있었는데..

처음 유저프로그램1을 실행을 하겠지. 이 사이 유저2,3은 아무것도 실행하지 못한다. (cpu가 하나이기 때문에..) 하나의 컴퓨를 여러명이 동시에 사용하려면 멀티프로그래밍을 사용하기 힘들어.

이를 한번에 동시에 쓸 수 있는 방법은???

- 1/100초 마다 cpu가 스위칭을 해줌.

즉, io를 만날때마다 스위칭해주는게 아니라 아주 짧은 시간동안 움직임.
그러면 유저가 3명이고 1/100초마다 스위칭이 된다면 한 사람마다 1초에 총 33번의 cpu가 할당되는 기회를 얻는다.

이렇게 되면 cpu는 워낙 빠르니까 유저 각각 33번씩 오니까 유저 혼자 컴퓨터를 사용하는 것처럼 느껴지는것.

이런 방식을
### Time Sharing System

시공유 시스템. 일정 시간이 지나면 강제절환(스위칭한다) 이런 대화형 시스템이 가능해짐(명령내리고 응답받고..) 이렇게 하면서 이제는 여러가지 기술이 새로 나오게 됨

- 사용자가 여러명인데 다른 사용자에게 메시지를 보낼 수도 있음(카카오톡..)
- 하나의 컴퓨터를 여러명이 쓰다보니까 서로 데이터를 주고받는것이 가능해짐
- 그래서 프로세스간 통신이 가능해짐
- 유저 1,2,3이 거의 동시에 실행되다 보니까 누가 앞서도 뒤서야하는지 알아봐야함(동기)
- 동기: 싱크로나이즈 > 여러명이 짝을 이뤄 움직이는것
  - 즉, 프로그램이 여러개 동시에 있다보니 누가 순서를 앞서도 뒤서야하는지를 해결해야함 이를 동기라고 함
- 유저가 3명보다 훨씬 더 많을수도 있는데, 메모리는 작은데 그 안에 유저가 늘어나는 상황에서 이 작은 메모리를 우리가 어떻게 해결해야할까?
  - 그래서 새로운 기술이 나타남: 이때는 하드디스크가 보편화됨
  - 메인메모리와 하드디스크: 하드디스크의 일부를 메인 메모리인양 사용하는 기술
  - 사실은 메인메모리가 아닌데, 하드디스크가 메인메모리처럼 보이게 하는 기술
  - 그래서 cpu가 보기에는 메인메모리가 크게 보이는것 > 가상메모리

운영체제는 성능향상을 시킨다고 했는데 바로 위에 저런 기능들을 통해서 성능향상을 시킬 수 있게 된것이다.


이때 대표적인 운영체제 시스템: Unix(60~70년대)
그러다가 unix->linux가 되었고 이런 시스템들이 다 time Sharing system을 기반으로 두고 있는 것이다. 그럼 윈도우 도스는????????

도스는 처음에 유저프로그램 딱 하나만 있던것. > 윈도우가 나오게 되면서 모두 TSS가 되었음

그리고 휴대폰들도 os가 있는데 이들도 다 TSS!
시간을 나누어서 이 시간에는 어떤일들을 하는지 여러번의 스위칭을 하면서 동시에 여러개의 일을 하는것처럼 보이게 함. 그래서 결론적으로 지금 우리가 사용하는 대부분의 운영체제는 TSS

그 이후로는 os의 특별한 발전은 없었는데, 왜냐하면 거의 완성이 됨!

단일 cpu를 사용한 가장 최신의 운영체제가 되었고 unix, linux도 마찬가지고 mac, 윈도우 모든 TSS를 사용하고 있음


## os 기술의 천이

컴퓨터를 얼마나 강력한가? 라는 구별에 따라서
- supercomputer: 가장 최강의 컴퓨터, 메모리용량도 크고 cpu도 빠르고 보조기억장치도 엄청나고..
- mainframe: 단말기 갯수가 한 컴퓨터에 수백대의 단말기를 달아 사용하는 것(수백명의 사람들이 동시에 사용하는 것)
- minicomputer: 이 단말기가 수십대
- micro..: 작으면 한명정도..

이건 옛날 구별이고 이제는

- supercomputer
- mainframe: 거의 없어..
그러나 이제는 인터넷 시대여서 네트워크를 공통으로 사용하는 pc와 pc보다 조금 작은 개념인 WORK STATION이 잇어 그래서 대부분의 작업ㅇㄹ pc에서 이루어지게 하는데 데이터 베이스 서버가 필요한 경우
- server: 여러개의 서버..
  - 그래서 회사나 학교만 봐도 대부분의 작은일들은 pc에서 하고 거기서 못하는 큰 일들은 서버에서 한다. 수십/수백개의 서버와 pc가 있음
- handheld: 손에 들고다니는 컴퓨터 / 노트북, 태플릿, 스마트폰..
- embedded: 어디에 파묻혀있다. 즉, 내장되어져있다.
  - 컴퓨터가 어디에 포함되어있다. 자동차안의 컴퓨터(엔진제어..), 전기밥솥 안의 cpu, 냉장고, 세탁기..
  - 우리 눈에는 안보이지만, 세탁기도 지능화되어야하니까 컴퓨터가 들어잇다.


이 모든 컴퓨터에는 모두 운영체제가 들어가 있다. 운영체제가 없으면 우리가 그것을 사용할 수가 없다. 그래서 아무리 간단해 보이는 컴퓨터라고 하더라도 모두 운영체제가 들어있다.

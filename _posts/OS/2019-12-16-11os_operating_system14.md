---
layout: post
title: 주기억장치 관리 개요(Main Memory Management)
category: OS
tags: [OS, operating system]
comments: true
---

> 개인공부 후 자료를 남기기 위한 목적임으로 내용 상에 오류가 있을 수 있습니다.    
경성대학교 양희재 교수님 수업 영상을 듣고 정리하였습니다.     

<hr>

## 메모리의 역사

- Core Memory: 반지모양 철심에 자석물질을 발라둬 전기가 흐르면 자석이 울리는 방식을 사용
- 진공관 메모리: 진공관 크기는 손가락 3~4개 정도
- 트랜지스터 메모리(반도체 칩안에 들어있는 소재 트랜지스터라고 함)-> 크기가 손톱만함, 1비트 저장하는데 4~6개가 들어감(많이 못넣음)
- 집적회로 메모리: SRAM(캐시메모리 만드는것), DRAM(메인메모리)


### 언제나 부족한 메모리

- 프로그램의 변천
  - 기계어/어셈블리어 작성 > C언어 작성 > 자바, 객체지향형 언어 작성을 하게되면서 프로그램의 크기가 커짐
  - 숫자 처리 > 문자 처리 > 멀티미디어 처리 > Big data 즉, 처리하는 자료도 커짐

- 메모리 용량 증가 vs 프로그램 크기 증가: 둘다 계속 증가! 언제나 부족한 메모리...!

- 어떻게 메모리를 효과적으로 사용할 수 있을까?
  - 메모리 낭비 없애기: 효과적으로 어떻게 사용할까?
  - 가상 메모리 (virtual memory): 실제 물리적인 메모리는 작은데, 크게 보이도록 가상의 메모리.


### 프로그램을 메모리에 올리기

<center>
<figure>
<img src="/assets/post-img/OS/37.jpeg" alt="" width="50%">
</figure>
</center>

- 메모리 구조: `주소(Address, 메모리의 입력) + 데이터(Data, 메모리의 출력)`

- 프로그램 개발
  - 원천파일(Resource file): 고수준언어 또는 어셈블리언어
  - 목적파일(Object file): 컴파일 또는 어셈블 결과(하이레벨 언어를 기계어로 변환)
  - 실행파일(Executable file): 링크결과

- 컴파일러(compiler), 어셈블러(assembler), 링커(linker), 로더(loader)

- 프로그램 실행: `code + data + stack(함수호출해서 돌아오는 주소 저장, 지역변수 저장)`

- 실행파일을 메모리에 올리기
  - 메모리 몇번지에?
  - 다중 프로그래밍 환경에서는?

- MMU사용: `재배치 레지스터(Relocation register)` > base/limit외에도 Relocation이 있음<br>
**os가 Relocation register를 이용해 번지수를 지정(address translation)해줌으로써 실제 메인메모리 어디에 들어가있는지와는 상관없이 프로그램이 실행될 수 있도록 함**<br>
  - 그래서 메모리의 몇번지에 올리는지는 중요한 이슈가 아니다.
  - 프로그램 설계자가 처음 hwp를 만들때 번지를 0번지로 설정을 해놓았는데 hwp가 실제 1000번지에 있다면 프로그램이 실행이 안된다.
  - 이를 제대로 실행될 수 있는 방법은 `Relocation register`가 담당한다
  - os가 hwp를 실행할 적에는 Relocation register에 1000이라는 값을 넣는다. 그래서 cpu가 hwp를 실행하려면 0번지에 있다고 생각하니
  - cpu는 0번지를 내어도 limit이 1000이 되어있어 1000번지에 있는 hwp도 실행이 가능하게 된다. (사실은 cpu가 속은것이다.)
  - **cpu는 0에 있는줄 알지만, 실제로는 1000에 있는것이다.**

- 주소구분
  - 논리주소(logical address, cpu가 내는 주소) vs 물리주소(physical address, 실제로 mmu를 통과해서 메인메모리오 오는 주소)
  - cpu는 항상 모든 주소가 0번지에서 돌고있다고 생각하며 Relocation register를 통해 프로그램들이 메인메모리의 어느 위치든 올리기가 가능해진다.
